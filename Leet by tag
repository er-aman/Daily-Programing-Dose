Linear Structure Basics
Includes: String, Array, Linked List

Difficulty Level: ( Easy | Medium ))



Must-Do
LeetCode88. Merge Sorted Array:--
        i=m-1
        k= len(nums1)-1
        j=n-1
        while i>=0 and j>=0:
          if nums1[i]<nums2[j]:
            nums1[k] = nums2[j]
            j-=1
            k-=1
          else:
            nums1[k]=nums1[i]
            i-=1
            k-=1
       nums1[:j+1] = nums2[:j+1]

LeetCode186. Reverse Words in a String II
             
             1st i need to define a reverse function which takes list, left and right pointers :- 
             2) revesrse the entire list using the function
             3) for loop over the list and check for empty space element and run the below function:
             self.reverse(s,0,len(s)-1) ===> reverses the list
             previous =0 
             for i in range(len(s)):
               if s[i]==" ":
                self.reverse(s,previous,i-1)
                previous=i+1
               elif s[i] == len(s)-1:
                self.reverse(s,previous,i)
             def reverse(self, s,left, right):
              while left<right:
                 s[left], s[right] = s[right],s[left]
                 left+=1
                 right-=1
            
              

LeetCode1. Two Sum
import collections
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        my_dict = {k:v for v,k in enumerate(nums)}
        for i in range(len(nums)):
            temp_res = target - nums[i]
            if temp_res in my_dict and my_dict[temp_res]!=i:
                return [i,my_dict[temp_res]]

LeetCode143. Reorder List

class Solution:
    def reorderList(self, head: ListNode) -> None:
        """
        Do not return anything, modify head in-place instead.
        """
        if not head:
            return
        fast=slow=head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        
        previous,cur = None, slow 
        while cur:
            cur.next,previous,cur = previous,cur,cur.next
        
        first,second = head,previous
        while second.next:
            first.next,first = second,first.next
            second.next,second = first,second.next

LeetCode92. Reverse Linked List II
 dummy=ListNode(0)
        dummy.next = head
        
        previous,cur= dummy,head
        for _ in range(m-1):
            cur= cur.next
            previous=previous.next
        for _ in range(n-m):
            temp=cur.next
            cur.next=temp.next
            temp.next=previous.next
            previous.next= temp
        return dummy.next
LeetCode56. Merge Intervals
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        sorted(intervals)
        res=[]
        for i in intervals:
            if not res or res[-1][1]<i[0]:
                res.append(i)
            else:
                res[-1][1]=max(res[-1][1],i[1])
        return res

LeetCode20. Valid Parentheses
class Solution:
    def isValid(self, s: str) -> bool:
        stack=[]
        my_dict = {"]":"[","}":"{",")":"("}
        for i in s:
            if i in my_dict:
                top_el = stack.pop() if stack else "#"
                if top_el != my_dict[i]:
                    return False
            else:
                stack.append(i)
        return not stack

LeetCode75. Sort Colors
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        red,white,blue = 0,0,len(nums)-1
        while white<=blue:
            if nums[white]==0:
                nums[red],nums[white]= nums[white],nums[red]
                red+=1
                white+=1
            elif nums[white]==1:
                white+=1
            else:
                nums[white],nums[blue]=nums[blue],nums[white]
                blue-=1
                
LeetCode155. Min Stack


class MinStack:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack=[]
        self.minStack=[]

    def push(self, x: int) -> None:
        self.stack.append(x)
        if not self.minStack or self.minStack[-1]>= x:
            self.minStack.append(x)
    def pop(self) -> None:
        temp= self.stack.pop()
        if temp == self.minStack[-1]:
            self.minStack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.minStack[-1]


# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(x)
# obj.pop()
# param_3 = obj.top()
#param_4 = obj.getMin()


LeetCode277. Find the Celebrity
class Solution:
    def findCelebrity(self, n: int):
        candidate=0
        for i in range(1,n):
            if knows(candidate,i):
                candidate=i
        for i in range(n):
            candidate_knows_i = knows(candidate,i)
            i_knows_cand= knows(i,candidate)
            if i!=candidate and (candidate_knows_i or not i_knows_cand):
                return -1
        return candidate

LeetCode281. Zigzag Iterator
class ZigzagIterator:
    def __init__(self, v1: List[int], v2: List[int]):
        self.queue = [_ for _ in (v1,v2) if _]

    def next(self) -> int:
        v=self.queue.pop(0)
        res=v.pop(0)
        if v:
            self.queue.append(v)
        return res
            
    def hasNext(self) -> bool:
        if self.queue:
            return True
        else:
            return False

57. insert interva
class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        if not intervals and newInterval:
            return [newInterval]
        i=0
        res=[]
        while i<len(intervals):
            if intervals[i][1]>= newInterval[0] and intervals[i][1]<= newInterval[1] :
                intervals[i][1] = max(intervals[i][1],newInterval[1])
                intervals[i][0] = min(intervals[i][0],newInterval[0])
                res.append([intervals[i][0],intervals[i][1]])
                newInterval=[float('inf'),float('inf')]
            else:
                res.append(intervals[i])
            i+=1
        if newInterval!=[float('inf'),float('inf')]:
            res.append(newInterval)
        res.sort()
        final_res=[res[0]]
        j=1
        while j<len(res):
            if final_res[-1][1]>=res[j][0]:
                final_res[-1][1]=max(final_res[-1][1],res[j][1])
            else:
                final_res.append(res[j])
            j+=1
        return final_res
71. Simplify Path

15. 3Sum
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        res = set()
        i =0
        nums.sort()
        while i<len(nums)-2:
            left,right=i+1,len(nums)-1
            while left<right:
                temp = nums[left]+nums[right]+nums[i]
                if temp>0:
                    right-=1
                elif temp<0:
                    left+=1
                else:
                    res.add((nums[left],nums[right],nums[i]))
                    left+=1
            i+=1
        return list(res)



Optional
LeetCode234. Palindrome Linked List

LeetCode283. Move Zeros

LeetCode242. Valid Anagram

import collections
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        s_res= collections.Counter(s)
        t_res = collections.Counter(t)
        
        key_set = set()
        for k in s_res.keys():
            key_set.add(k)
        for k in t_res.keys():
            key_set.add(k)
        for key in key_set:
            if s_res[key] != t_res[key]:
                return False
        
        return True

16. 3sum closest

class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        closest = nums[0] + nums[1] + nums[2]
        nums.sort()
        
        for i in range(len(nums)-2):
            l= i+1
            
            r= len(nums)-1
            
            while l<r:
                total = nums[i]+ nums[l] + nums[r]
                
                if abs(target-total) < abs(target - closest):
                    closest = total
                
                if total< target:
                    l+=1
                
                elif total > target:
                    r -=1
                else:
                    return closest
            
        return closest

246. Strobogrammatic Number



82. Remove Duplicates from Sorted list II

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        dummy = ListNode(-1)
        dummy.next = head
        
        l,r= dummy, dummy.next 
        
        while r:
            if r.next and r.val == r.next.val:
                val_remember = r.val
                
                while r and r.val==val_remember:
                    r = r.next
                
                l.next =r
            else:
                l, r = r, r.next
        
        return dummy.next
        
380. Insert delete getrandom O(1)

from random import choice
class RandomizedSet:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.lookup={}
        self.myList=[]

    def insert(self, val: int) -> bool:
        """
        Inserts a value to the set. Returns true if the set did not already contain the specified element.
        """
        if val not in self.lookup:
            self.lookup[val] = len(self.myList)
            self.myList.append(val)
            return True
        return False

    def remove(self, val: int) -> bool:
        """
        Removes a value from the set. Returns true if the set contained the specified element.
        """
        if val in self.lookup:
            last, idx = self.myList[-1], self.lookup[val]
            self.myList[idx] = last
            self.myList.pop()
            self.lookup[last]=idx
            del self.lookup[val]
            return True
        return False

    def getRandom(self) -> int:
        """
        Get a random element from the set.
        """
        return choice(self.myList)
        


# Your RandomizedSet object will be instantiated and called as such:
# obj = RandomizedSet()
# param_1 = obj.insert(val)
# param_2 = obj.remove(val)
# param_3 = obj.getRandom()

11 container with most water

189 rotate array

class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        temp_arr = nums[len(nums)-k::] + nums[0:((len(nums)-k))]
        for i in range(len(temp_arr)):
            nums[i] = temp_arr[i]

48 rotate image

class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        for i in range(len(matrix)):
            for j in range(i,len(matrix)):
                matrix[j][i], matrix[i][j]= matrix[i][j], matrix[j][i]
                
        
        for row in matrix:
            row=row.reverse()

225 implement stack using queues

import collections

class Queue:
    def __init__(self):
        self.q_ = collections.deque()
    def push(self,x):
        self.q_.append(x)
    def pop(self):
        return self.q_.popleft()
    def top(self):
        return self.q_[0]
    def size(self):
        return len(self.q_)
    def empty(self):
        return len(self.q_)==0 

class MyStack:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.stack = Queue()
        
    def push(self, x: int) -> None:
        """
        Push element x onto stack.
        """
        self.stack.push(x)
        for _ in range(self.stack.size() -1):
            self.stack.push(self.stack.pop())
    def pop(self) -> int:
        """
        Removes the element on top of the stack and returns that element.
        """
        return self.stack.pop()

    def top(self) -> int:
        """
        Get the top element.
        """
        return self.stack.top()

    def empty(self) -> bool:
        """
        Returns whether the stack is empty.
        """
        return self.stack.size()==0


# Your MyStack object will be instantiated and called as such:
# obj = MyStack()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.empty()






Linear Structure Advanced
Includes: String, Array, Linked List
Difficulty Level: ( Medium | Hard )


Must-Do
LeetCode259. 3Sum Smaller

class Solution:
    def threeSumSmaller(self, nums: List[int], target: int) -> int:
        count = 0 
        nums.sort()
        for i in range(len(nums)-2):
            l= i+1
            r= len(nums)-1
            
            while l<r:
                total = nums[i]+nums[l]+nums[r]
                
                if total<target:
                    count += r-l
                    l+=1
                else:
                    r-=1
        return count


LeetCode532. K-diff Pairs in an Array

LeetCode567. Permutation in String

LeetCode76. Minimum Window Substring

LeetCode85. Maximal Rectangle

LeetCode475. Heaters

LeetCode340. Longest Substring with At Most K Distinct Characters

LeetCode42. Trapping Rain Water



class Solution:
    def trap(self, height: List[int]) -> int:
        p,q = 0, len(height)-1
        lmax,rmax =0,0
        water =0
        while p<q:
            if height[p]<= height[q]:
                if height[p]> lmax:
                    lmax = height[p]
                else:
                    water = water + lmax - height[p]
                p+=1
            else:
                if height[q]>rmax:
                    rmax = height[q]
                else:
                    water += rmax - height[q]
                q-=1
        return water

LeetCode239. Sliding Window Maximum

LeetCode274. H-Index

LeetCode275. H-Index II

LC 26. Remove Duplicates from Sorted Array

class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums)>1:
            i = len(nums)-1
            while i>0:
                if nums[i]==nums[i-1]:
                    nums.pop(i)
                i-=1
        

LC 80. Remove Duplicates from Sorted Array II

LC 442. Find All Duplicates in an Array

class Solution:
    def findDuplicates(self, nums: List[int]) -> List[int]:

        res=[]
        for i in nums:
            if nums[abs(i)-1]<0:
                res.append(abs(i))
            else:
                nums[abs(i)-1] *=-1
        
        return res

LC 448. Find All Numbers Disappeared in an Array

class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        for i in range(len(nums)):
            new_index = abs(nums[i])-1
            if nums[new_index]>0:
                nums[new_index]*=-1  
        
        res=[]
        
        for i in range(1,len(nums)+1):
            if nums[i-1]>0:
                res.append(i)
        
        return res

LC 41. First Missing Positive

LC 268. Missing Number

class Solution:
    def missingNumber(self, nums):
        num_set = set(nums)
        n = len(nums) + 1
        for number in range(n):
            if number not in num_set:
                return number
                
LC 287. Find the Duplicate Number

import collections
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        count = collections.Counter(nums)
        
        for key in count.keys():
            if count[key]>=2:
                return key

LC 54 Spiral Matrix
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix:
            return []
        top=left=0
        right = len(matrix[0])-1
        bottom = len(matrix)-1
        res=[]
        while left<=right and top<=bottom:
            if left == right:
                for i in range(top,bottom+1):
                    res.append(matrix[i][left])
                break
            if top==bottom:
                for i in range(left,right+1):
                    res.append(matrix[top][i])
                break
            
            for i in range(left,right+1):
                res.append(matrix[top][i])
            
            for i in range(top+1,bottom+1):
                res.append(matrix[i][right])
            for i in reversed(range(left,right)):
                res.append(matrix[bottom][i])
            
            for i in reversed(range(top+1,bottom)):
                res.append(matrix[i][left])
            
            top+=1
            left+=1
            right-=1
            bottom-=1
        
        return res

84. Largest Rectangle in Histogram (H)

105 Construct Binary Tree from Preorder and Inorder Traversal





Optional
LeetCode658. Find K Closest Elements

LeetCode159. Longest Substring with At Most Two Distinct Characters

LC 316. Remove Duplicate Letters

LC 142. Linked List Cyle II

LC 224 Basic Calculator

LC 227 Basic Calculator II

LC 59 Spiral Matrix II






Recursion + Search  - Basic
Includes: Recursion + Binary Search + Tree
Difficulty Level: ( Easy | Medium )



Must-Do
206. Reverse Linked List

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseUtil(self,head,node):
        if not head:
            return node
        temp = head.next
        head.next = node
        return self.reverseUtil(temp,head)
    def reverseList(self, head: ListNode) -> ListNode:
        return self.reverseUtil(head,None)
        

LeetCode278. First Bad Version

# The isBadVersion API is already defined for you.
# @param version, an integer
# @return an integer
# def isBadVersion(version):

class Solution:
    def firstBadVersion(self, n):
        """
        :type n: int
        :rtype: int
        """
        start =0 
        end = n 
        
        while start +1 < end:
            mid = start + (end -start)//2
            
            if isBadVersion(mid):
                end = mid
            else:
                start = mid
                
        return end


LeetCode34. Search for a Range

class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        def search(n):
            l,r = 0, len(nums)
            while l<r:
                mid = l+(r-l)//2
                if nums[mid]>=n:
                    r = mid
                else:
                    l=mid+1
            return l
                    
        start = search(target)
        
        return [start, search(target+1)-1] if target in nums[start : start+1] else [-1,-1]


LeetCode450. Delete Node in a BST

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    
    def successor(self,root):
        root = root.right
        while root.left:
            root=root.left

        return root.val 
        
    def predecessor(self,root):
        root = root.left
        while root.right:
            root = root.right

        return root.val
    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
        
        
        
        if not root:
            return None 
        
        if key > root.val:
            root.right = self.deleteNode(root.right,key)
        
        elif key < root.val:
            root.left = self.deleteNode(root.left,key)
        
        else:
            if not root.left and not root.right:
                root= None
            
            elif root.right:
                root.val = self.successor(root)
                root.right = self.deleteNode(root.right,root.val)
            else:
                root.val = self.predecessor(root)
                root.left = self.deleteNode(root.left,root.val)
        
        return root
            


LeetCode156. Binary Tree Upside Down

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def upsideDownBinaryTree(self, root: TreeNode) -> TreeNode:
        if not root or (not root.left and not root.right):
            return root 
        lroot = self.upsideDownBinaryTree(root.left)
        
        temp = lroot
        while temp.right:
            temp=temp.right
        
        temp.right = TreeNode(root.val)
        temp.left= root.right
        return lroot

LeetCode98. Validate Binary Search Tree

        res=[]
        def inOrder(root):
            if not root:
                return None
            left = inOrder(root.left)
            res.append(root.val)
            right = inOrder(root.right)
        inOrder(root)
        for i in range(1,(len(res))):
            if res[i]<=res[i-1]:
                return False
        return True



Lowest Common Ancestor of a Binary Tree

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if p == root or q == root:
            return root
        
        
        left=right=None 
        if root.left:
            left = self.lowestCommonAncestor(root.left,p,q)
        if root.right:
            right = self.lowestCommonAncestor(root.right,p,q)
        
        if left and right:
            return root
    
        
        return left or right

LeetCode153. Find Minimum in Rotated Sorted Array

class Solution:
    def findMin(self, nums: List[int]) -> int:
        l,r = 0, len(nums)-1
        while l<r and nums[l]>=nums[r]:
            mid = (l+r)//2
            if nums[mid]<nums[l]:
                r=mid
            else:
                l = mid +1
        return nums[l]

LeetCode154. Find Minimum in Rotated Sorted Array II

def findMin(nums):
    l,r = 0, len(nums)-1
    # [2,3,4,5,6,7] => [5,6,7,2,2,3,3,4,4]
                              
    while l<r:
        mid = (l+r)//2
        if nums[mid]>nums[r]:
            l= mid +1
        elif nums[mid]<nums[r]:
            r= mid
        else:
            r-=1
    return nums[l]

LeetCode144. Binary Tree Preorder Traversal

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        def dfs(root,res):
            if root:
                res.append(root.val)
                dfs(root.left,res)
                dfs(root.right,res)
                
        res=[]
        dfs(root,res)
        return res

104. Maximum Depth of Binary Tree

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        
        left = self.maxDepth(root.left)
        right = self.maxDepth(root.right)
        
        return 1 + max(left,right)

111. Minimum Depth of Binary Tree

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        if root.left and root.right:
            left = self.minDepth(root.left)
            right = self.minDepth(root.right)
            
            return 1 + min(left,right)
        
        elif  root.left:
            return 1 + self.minDepth(root.left)
        
        else:  
            return 1 + self.minDepth(root.right)

257. Binary Tree Paths

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        def construct_paths(root,path):
            if root:
                path+=str(root.val)
                if not root.left and not root.right:
                    paths.append(path)
                else:
                    path+="->"
                    construct_paths(root.left,path)
                    construct_paths(root.right,path)
        
        
        paths=[]
        construct_paths(root,'')
        
        return paths
        
        
101. Symmetric Tree

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def search(self,p,q):
        if not p and not q:
            return True
        if not p or not q or p.val != q.val:
            return False
        return self.search(p.left,q.right) and self.search(p.right, q.left)
    def isSymmetric(self, root: TreeNode) -> bool:
        return self.search(root.left, root.right) if root else True

110. Balanced Binary Tree

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def lookup(self,root):
        if not root:
            return 0 
        left_height, right_height = self.lookup(root.left),self.lookup(root.right)
        if left_height<0 or right_height<0 or abs(left_height-right_height)>1:
            return -1
        return max(left_height,right_height)+1
    def isBalanced(self, root: TreeNode) -> bool:
        return self.lookup(root)>=0





Optional
LeetCode235. Lowest Common Ancestor of a Binary Search Tree

LeetCode33. Search in Rotated Sorted Array

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        if not nums:
            return -1
        
        left,right = 0, len(nums)-1
        while left+1<right:
            mid = left +(right-left)//2
            if nums[mid]==target:
                return mid
            elif nums[left]<= nums[mid]:
                if nums[left]<=target and target<nums[mid]:
                    right=mid
                else:
                    left=mid
            else:
                if target<=nums[right] and target>nums[mid]:
                    left=mid
                else:
                    right=mid
                    
        if nums[left]==target:
            return left
        if nums[right]==target:
            return right
        return -1
            

LeetCode94. Binary Tree Inorder Traversal

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        def inorder(root, res):
            if root:
                inorder(root.left,res)
                res.append(root.val)
                inorder(root.right,res)
        
        res=[]
        inorder(root,res)
        
        return res

LeetCode145. Binary Tree Postorder Traversal

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        def utils(root,res):
            if root:
                utils(root.left,res)
                utils(root.right,res)
                res.append(root.val)
        
        res=[]
        utils(root,res)
        
        return res

LeetCode102. Binary Tree Level Order Traversal

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        res=[]
        
        queue = [root]
        
        while queue:
            temp_list =[]
            for _ in range(len(queue)):
                cur_node = queue.pop(0)
                temp_list.append(cur_node.val)
                if cur_node.left:
                    queue.append(cur_node.left)
                if cur_node.right:
                    queue.append(cur_node.right)
            res.append(temp_list)
        return res

LeetCode81. Search in Rotated Sorted Array II

129. Sum Root to Leaf Numbers

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:        
    def sumNumbers(self, root: TreeNode) -> int:
        
        if not root:
            return 0 
        
        if not root.left and not root.right:
            return int(root.val)
        
        if root.left: root.left.val = 10*(root.val) + root.left.val
        if root.right: root.right.val = 10*(root.val) + root.right.val
        
        return self.sumNumbers(root.left) + self.sumNumbers(root.right)






Recursion + Search  - Advanced
Includes: Recursion + Binary Search + Tree
Difficulty Level: ( Medium | Hard )


Must-Do
LeetCode772. Basic Calculator III

LeetCode255. Verify Preorder Sequence in Binary Search Tree

LeetCode105. Construct Binary Tree from Preorder and Inorder Traversal

LeetCode436. Find Right Interval

LeetCode315. Count of Smaller Numbers After Self

LeetCode208. Implement trie tree
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.head={}

    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self.head
        for ch in word:
            if ch not in cur:
                cur[ch]={}
            cur= cur[ch]
        cur["*"]= True
    def search(self, word: str) -> bool:
        """
        Returns if the word is in the trie.
        """
        cur = self.head
        for ch in word:
            if ch not in cur:
                return False
            cur= cur[ch]
        if "*" in cur:
            return True
        else:
            return False
    def startsWith(self, prefix: str) -> bool:
        """
        Returns if there is any word in the trie that starts with the given prefix.
        """
        cur = self.head
        for ch in prefix:
            if ch not in cur:
                return False
            cur= cur[ch]
        return True
        


# Your Trie object will be instantiated and called as such:
# obj = Trie()
# obj.insert(word)
# param_2 = obj.search(word)
# param_3 = obj.startsWith(prefix)
LeetCode29. Divide Two Integers

LeetCode307. Range Sum Query - Mutable

LeetCode4. Median of Two Sorted Arrays

LeetCode297. Serialize and Deserialize Binary Tree

LeetCode776. Split BST

LeetCode114. Flatten Binary Tree to Linked List

LeetCode298. Binary Tree Longest Consecutive Sequence

LeetCode99. Recover Binary Search Tree

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def recoverTree(self, root: TreeNode) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        def inorder(root):
            return inorder(root.left) + [root.val]+ inorder(root.right) if root else []
        
        def getSwap(nums):
            n=len(nums)
            x=y=-1
            for i in range(n-1):
                if nums[i+1]<nums[i]:
                    y= nums[i+1]
                    if x==-1:
                        x=nums[i]
                    else:
                        break
            return x,y
        
        def recover(r:TreeNode,count):
            if r:
                if r.val ==x or r.val ==y:
                    r.val=y if r.val==x else x
                    count-=1
                    if count ==0:
                        return 
                recover(r.left,count)
                recover(r.right,count)
            
        nums =inorder(root)
        x,y = getSwap(nums)
        recover(root,2)
        

QuickSort implementation

LeetCode384. Shuffle an Array

LeetCode378. Kth Smallest Element in a Sorted Matrix

LeetCode74 Search in 2D Matrix

LeetCode240 Search in 2D Matrix II





Optional
LeetCode303. Range Sum Query

LeetCode261. Graph Valid Tree

LeetCode230. Kth Smallest Element in a BST

LeetCode103. Binary Tree Zigzag Level Order Traversal

LeetCode367. Valid Perfect Square

LeetCode508. Most Frequent Subtree Sum

LeetCode250. Count Univalue Subtrees






Sorting | Graph  - Basic
Includes: Sorting | Graph | DFS | BFS
Difficulty Level: ( Easy | Medium )


Must-Do
75. Sort Colors

class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        l=cur=0
        r = len(nums)-1
        
        while cur<=r:
            if nums[cur]==0:
                nums[l], nums[cur] = nums[cur], nums[l]
                l+=1
                cur+=1
            elif nums[cur]==2:
                nums[r],nums[cur]=nums[cur],nums[r]
                r-=1
            else:
                cur+=1


LeetCode133. Clone Graph



LeetCode207. Course Schedule



LeetCode210. Course Schedule II

class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        
        in_degree = collections.defaultdict(set)
        out_degree = collections.defaultdict(set)
        
        for i,j in prerequisites:
            in_degree[i].add(j)
            out_degree[j].add(i)
            
        stack =[i for i in range(numCourses) if i not in in_degree]
        res =[]
        while stack:
            course = stack.pop()
            res.append(course)
            for i in out_degree[course]:
                in_degree[i].remove(course)
                if not in_degree[i]:
                    stack.append(i)
                    del in_degree[i]
            del out_degree[course]
        return res if not in_degree and not out_degree else []
        

LeetCode490. The Maze



LeetCode505. The Maze II



LeetCode46. Permutations

Time and space complexity is O(NN!)
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res=[]
        self.dfs(nums,[],res)
        return res
    
    def dfs(self,ds,fixed_path,res):
        if not ds:
            res.append(fixed_path)
            return
        
        for i in range(len(ds)):
            self.dfs(ds[:i]+ds[i+1:],fixed_path+[ds[i]],res)

LeetCode47. Permutations II



LeetCode200. Number of Islands

class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid:
            return 0
        count=0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j]=="1":
                    self.is_island(grid,i,j)
                    count+=1
        return count 
    
    def is_island(self,grid,i,j):
        if not (0<=i<len(grid) and 0<=j<len(grid[0])) or grid[i][j]=='visited' or grid[i][j]!="1":
            return    
        directions =[(-1,0),(0,1),(1,0),(0,-1)]
        for m,n in directions:
                grid[i][j]='visited'
                self.is_island(grid,i+m,j+n)
                

LeetCode305. Number of Islands II



692. Top K Frequent Words

class Solution:
    def topKFrequent(self, words: List[str], k: int) -> List[str]:
        lookup = collections.Counter(words)
        heap =[(-val,key) for key,val in lookup.items()]
        heapq.heapify(heap)
        res=[]
        for _ in range(k):
            res.append(heapq.heappop(heap)[1])
        return res



LeetCode286. Walls and Gates



LC 77 Combinations



LC 78 Subsets



52. N-Queens II





Optional
22. Generate Parentheses

LeetCode787. Cheapest Flights Within K Stops

499. The Maze III

222. Count Complete Tree Nodes

347. Top K Frequent Elements

class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        lookup = collections.Counter(nums)
        keys = list(lookup.keys())
        values = list(lookup.values())
        res =[]
        for _ in range(k):
            max_val = max(values)
            ind_max = values.index(max_val)
            res.append(keys[ind_max])
            keys.pop(ind_max)
            values.pop(ind_max)
        return res

295. Find Median from Data Stream

class solution:
        def __init__(self):
                self.small=[]
                self.large=[]
       def add(self,num):
        if len(self.small) == len(self.large):
               heappush(self.large, -heappushpop(self.small ,-num))
        else:
               heappush(self.small, -heappushpop(self.large,num))
       def findMedian(self):
        if len(self.large) == len(self.small):
                return float(self.large[0]-self.small[0])/2.0
        else:
                return float(self.large[0])
                
261. Graph Valid Tree

253. Meeting Room II

207. Course Schedule

339. Nested List Weight Sum

23. Merge k Sorted Lists

199. Binary Tree Right Side View

90. Subset II

301. Remove invalid parentheses(DFS & BFS)



Sorting | Graph  - Advanced
Includes: Sorting | Graph | DFS | BFS
Difficulty Level: ( Medium | Hard )


Must-Do
LeetCode74. Search in 2D Matrix

class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        rows = len(matrix)
        if rows==0:
            return False
        cols = len(matrix[0])
        l,r= 0, rows*cols-1
        while l<=r:
            mid = l +(r-l)//2
            mid_element = matrix[mid//cols][mid%cols]
            if mid_element == target:
                return True
            else:
                if mid_element<target:
                    l+=1
                else:
                    r-=1
        return False
            

LeetCode240. Search in 2D Matrix II


LeetCode127. Word Ladder

O(m**2 x n) 

from collections import defaultdict
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        if endWord not in wordList or not endWord or not beginWord or not wordList:
            return 0

        # Since all words are of same length.
        L = len(beginWord)

        # Dictionary to hold combination of words that can be formed,
        # from any given word. By changing one letter at a time.
        all_combo_dict = defaultdict(list)
        for word in wordList:
            for i in range(L):
                # Key is the generic word
                # Value is a list of words which have the same intermediate generic word.
                all_combo_dict[word[:i] + "*" + word[i+1:]].append(word)
                print(all_combo_dict)
        # Queue for BFS
        queue = collections.deque([(beginWord, 1)])
        # Visited to make sure we don't repeat processing same word.
        visited = {beginWord: True}
        while queue:
            current_word, level = queue.popleft()      
            for i in range(L):
                # Intermediate words for current word
                intermediate_word = current_word[:i] + "*" + current_word[i+1:]

                # Next states are all the words which share the same intermediate state.
                for word in all_combo_dict[intermediate_word]:
                    # If at any point if we find what we are looking for
                    # i.e. the end word - we can return with the answer.
                    if word == endWord:
                        return level + 1
                    # Otherwise, add it to the BFS Queue. Also mark it visited
                    if word not in visited:
                        visited[word] = True
                        queue.append((word, level + 1))
        return 0

LeetCode126. Word Ladder II

LeetCode286. Walls and Gates

import collections
class Solution:
    def wallsAndGates(self, rooms: List[List[int]]) -> None:
        """
        Do not return anything, modify rooms in-place instead.
        """
        if not rooms:
            return []
        rows = len(rooms)
        cols = len(rooms[0])
        queue = collections.deque()
        for i in range(rows):
            for j in range(cols):
                if rooms[i][j] ==0:
                    queue.append((i,j))
        
        while queue:
            x,y = queue.popleft()
            
            for i,j in [(1,0),(0,-1),(0,1),(-1,0)]:
                if 0<=x+i<rows and 0<=y+j<cols and rooms[x+i][y+j]>rooms[x][y]:
                    rooms[x+i][y+j] = rooms[x][y] + 1
                    queue.append((x+i,y+j))

LeetCode305. Number of Island II

LeetCode323. Number of Connected Components in an Undirected Graph

LeetCode353. SNAKE

LeetCode269. Alien Dictionary

LeetCode417. Pacific Atlantic Water Flow

LeetCode773. Sliding Puzzle

LeetCode547. Friend Circles

LeetCode425. Word Squares

LeetCode444. Sequence Reconstruction

LeetCode373. Find K Pairs with Smallest Sums

LeetCode45. Jump Game II




Optional
LeetCode785. Is Graph Bipartite

LeetCode839. Similar String Groups

LeetCode352. Data Stream as Disjoint Intervals

LeetCode973. Kth Closest Points

class Solution:
    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:
        points.sort(key= lambda p: p[0]**2 + p[1]**2)
        return points[:K]
    
LeetCode684. Redundant Connection

LeetCode802. Find Eventual Safe States

LeetCode737. Sentence Similarity II

LeetCode317. Shortest Distance from All Buildings

LeetCode399. Evaluate Division







Memorization | DP  - Basic
Includes: Sorting | Graph | DFS | BFS
Difficulty Level: ( Easy | Medium )


Must-Do
LeetCode198. House Robber

class Solution:
    def rob(self, nums: List[int]) -> int:
        n= len(nums)
        if n==0:
            return 0 
        dp = [0]*n
        dp[n-1]= nums[n-1]
        dp[n-2]=max(nums[n-1],nums[n-2])
        
        for i in range(n-3,-1,-1):
            dp[i]= max(nums[i]+dp[i+2], dp[i+1])
        
        return dp[0]

LeetCode213. House Robber II

class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 0: return 0
        if len(nums) == 1: return nums[0]
        if len(nums) == 2: return max(nums)
        def rob_helper(nums):
            n= len(nums)
            if n==0:
                return 0 
            dp = [0]*n
            dp[n-1]= nums[n-1]
            dp[n-2]=max(nums[n-1],nums[n-2])

            for i in range(n-3,-1,-1):
                dp[i]= max(nums[i]+dp[i+2], dp[i+1])
            return dp[0]
        return max(rob_helper(nums[:-1]), rob_helper(nums[1:]))

63. Unique Paths II

class Solution:
Time and space is O(mn)
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        rows = len(obstacleGrid)
        if rows ==0:
            return -1
        cols = len(obstacleGrid[0])
        dp =[[0]*cols for _ in range(rows)]
        for i in range(cols):
            if obstacleGrid[0][i] ==1:
                break
            dp[0][i]=1
        
        for i in range(rows):
            if obstacleGrid[i][0] ==1:
                break
            dp[i][0]=1
        
        for i in range(1,rows):
            for j in range(1,cols):
                if obstacleGrid[i][j]==1:
                    continue
                else:
                    dp[i][j]= dp[i][j-1] + dp[i-1][j]
        return dp[-1][-1]
        

LeetCode322. Coin Change


LeetCode518. Coin Change II

39. Combination Sum

40. Combination Sum II

377. Combination Sum IV

72. Edit Distance

403. Frog Jump

309. Best Time to Buy and Sell Stock with Cooldown

LeetCode53. Maximum Subarray

LeetCode486. Predict the Winner =Pot of Gold Game

LeetCode139. Word Break

LeetCode300. Longest Increasing Subsequence

LeetCode152. Maximum Product Subarray





Optional
542 01 matrix

LeetCode.10 Regular Expression Matching

LeetCode.64 Minimum Path Sum

LeetCode.291 Word Pattern II

LeetCode.79 word search

class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        if len(board)==0:
            return False
        if len(word)==0:
            return False
        for i in range(len(board)):
            for j in range(len(board[0])):
                
                if self.exists_helper(board,i,j,word,0):
                    return True
                
        return False
        
    def exists_helper(self,board,i,j,word,index):
        directions = [(-1,0),(0,-1),(1,0),(0,1)]
        if len(word)==index:
            return True

        if 0<=i<len(board) and 0<=j<len(board[0]) and board[i][j]!='visited' and board[i][j]== word[index]:
            board[i][j] = 'visited'
            res = False

            for m,n in directions:
                res = res or self.exists_helper(board,i+m,j+n,word,index+1)
            board[i][j] = word[index]
            return res
        
                

216. Combination Sum III

70. Climbing Stairs

LeetCode279. Perfect Squares

LeetCode673. Number of Longest Increasing Subsequence

LeetCode140. Word Break II





Memorization | DP  - Advanced
Includes: Sorting | Graph | DFS | BFS
Difficulty Level: ( Medium | Hard )


Must-Do
LeetCode801. Minimum Swaps To Make Sequences Increasing

LeetCode790. Domino and Tromino Tiling

LeetCode764. Largest Plus Sign

LeetCode750. Number Of Corner Rectangles

LeetCode413. Arithmetic Slices

LeetCode446. Arithmetic Slices II - Subsequence

LeetCode132. Palindrome Partitioning II

LeetCode91. Decode Ways

LeetCode639. Decode Ways II

LeetCode354. Russian Doll Envelopes

LC 32. Longest Valid Parentheses

LC 55. Jump Game

LC 375. Guess Number Higher or Lower II

LC 363. Max Sum of Rectangle No Larger Than K

LC 44. Wildcard Matching



Optional
LC337. House Robber III

LC525. Contiguous Array

LC174. Dungeon Game

LC410. split array largest sum

LC5. Longest Palindromic Substring

LC516. Longest Palindromic Subsequence

LC312. burst ballons

LC212. Word Pattern II

LC 464. Can I Win

LeetCode787. Cheapest Flights Within K Stops

LC95. Unique Binary Search Trees II

LC96. Unique Binary Search Trees

LC97. Interleaving String

LC135. Candy

LC329. Longest Increasing Path in Matrix







Amazon
~~~~~~~~~~

632. Smallest Range Covering Elements from K Lists

Time Complexity is O(nlogm)

class Solution:
    def smallestRange(self, nums: List[List[int]]) -> List[int]:
        heap=[]
        rangeStart=0
        range_end = float('inf')
        current_max = float('-inf')
        
        for i in range(len(nums)):
            heapq.heappush(heap,(nums[i][0],0,i))
            current_max = max(current_max, nums[i][0])
        
        while len(heap)==len(nums):
            num,idx,row = heapq.heappop(heap)
            if range_end - rangeStart >  current_max - num:
                rangeStart = num 
                range_end = current_max
            
            if idx+1< len(nums[row]):
                heapq.heappush(heap,(nums[row][idx+1],idx+1,row))
                current_max = max(current_max,nums[row][idx+1])
                
        return [rangeStart,range_end]
        
   
   
733. Flood Fill 

import collections
class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
        if image[sr][sc]== newColor:
            return image
        queue = collections.deque([(sr,sc)])
        color = image[sr][sc]
        visited={(sr,sc)}
        while queue:
            
            cur_r, cur_c = queue.popleft()
            image[cur_r][cur_c]=newColor
            for i,j in [(1,0),(-1,0),(0,-1),(0,1)]:
                new_r = cur_r+i 
                new_c = cur_c+j 
                
                if 0<= new_r<len(image) and 0 <= new_c<len(image[0]) and image[new_r][new_c]==color:
                    if (new_r,new_c) not in visited:
                        visited.add((new_r,new_c))
                        queue.append((new_r,new_c))
        
        return image
                    

1197. Minimum Knight Moves

import collections
class Solution:
    def minKnightMoves(self, x: int, y: int) -> int:
        queue = collections.deque([])
        queue.append((0,0,0))
        visited = {(0,0)}
        while queue:
            i,j,steps = queue.popleft()
            if i ==x and j==y:
                return steps
            
            directions = [(-2,-1),(-2,1),(2,1),(2,-1),(-1,2),(-1,-2),(1,2),(1,-2)]
            for m,n in directions:
                new_row = i+m
                new_col = j+n
                if (new_row, new_col) not in visited:
                    visited.add((new_row, new_col))
                    queue.append((new_row, new_col, steps+1))
        return -1
        
        
   78. Subsets
   
   class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res=[[]]
        for num in nums:
            res+=[i+[num] for i in res]
        return res
        
   subset for chars:
   def getSubStrings(string):
          str_list=[i for i in string]
          res=['']
          for ch in str_list:
            res+=[i+ch for i in res]
          return sorted(res[1:])

print(getSubStrings('abc'))
    
   90. Subsets II
   
   class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        res = [[]]
        nums.sort()
        for num in nums:
            res+=[i+[num] for i in res]
        lookup = {}
        for i in res:
            lookup[str(i)]=0
        res=[]
        for key in lookup.keys():
            res.append(eval(key))
        return res

1315. Sum of Nodes with Even-Valued Grandparent

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sumEvenGrandparent(self, root: TreeNode) -> int:
        def dfs(node,parent,grandparent):
            if not node:
                return
            nonlocal answer
            if parent and grandparent and grandparent.val%2==0:
                answer+=node.val
            dfs(node.left,node,parent)
            dfs(node.right,node,parent)
                
        answer=0
        dfs(root,None,None)
        return answer 

1395. Count Number of Teams

class Solution:
    def numTeams(self, rating: List[int]) -> int:
        n = len(rating)
        
        up = [0] * n
        down = [0] * n
        
        teams = 0
        
        for i in range(n-1, -1, -1):
            for j in range(i+1, n):
                if rating[i] < rating[j]:
                    up[i] += 1
                    teams += up[j]
                else:
                    down[i] += 1
                    teams += down[j]
        
        return teams


1038. Binary Search Tree to Greater Sum Tree

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    val=0
    def bstToGst(self, root: TreeNode) -> TreeNode:
        if root.right:
            self.bstToGst(root.right)
        root.val = self.val = self.val+root.val
        if root.left:
            self.bstToGst(root.left)
        return root


535. Encode and Decode TinyURL

from hashlib import sha256
import unittest
class TinyUrl:
  def __init__(self):
    self.lookup ={}
  
  def encode(self,long_url):
    key_set = sha256(long_url.encode()).hexdigest()[:6]
    tiny_url = "http://tinyurl.com/"+key_set
    self.lookup[tiny_url]=long_url
    return tiny_url
  
  
  def decode(self,tiny_url):
    return self.lookup[tiny_url]
  

obj = TinyUrl()
print(obj.encode("https://leetcode.com/problems/design-tinyurl"))
print(obj.decode("http://tinyurl.com/f86ef1"))




797. All Paths From Source to Target


import collections
def allPathsFromSourceToTarget(graph):
  n= len(graph)
  target = n-1
  result =[]
  
  def dfs(cur_node,path):
    #base case
    if cur_node == target:
      result.append(list(path))
      return
    
    for neighbour in graph[cur_node]:
      path.append(neighbour)
      dfs(neighbour,path)
      path.pop()
  
  path= collections.deque([0])
  dfs(0,path)
  return result

print(allPathsFromSourceToTarget([[1,2],[3],[3],[]]))

Time complexity and space complexity is 2**N *N where 
N is no. of nodes in the graph


1008. Construct Binary Search Tree from Preorder Traversal

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:
        def helper(lower=float('-inf'),high=float('inf')):
            nonlocal idx
            if idx == len(preorder):
                return None
            val = preorder[idx]
            if val<lower or val> high:
                return None
            root = TreeNode(val)
            idx+=1
            root.left = helper(lower,val)
            root.right = helper(val,high)

            return root
        idx=0
        return helper()

Time and space complexity is O(n)


1325. Delete Leaves With a Given Value

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def removeLeafNodes(self, root: TreeNode, target: int) -> TreeNode:
        if root:
            root.left = self.removeLeafNodes(root.left,target)
            root.right = self.removeLeafNodes(root.right,target)
            if root.val!=target or root.left or root.right:
                return root

701. Insert into a Binary Search Tree

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:
        if not root:
            return TreeNode(val)
        
        if val<root.val:
            root.left = self.insertIntoBST(root.left,val)
        else:
            root.right = self.insertIntoBST(root.right,val)
        
        return root
Time complexity is O(H) => O(log n) average case and O(N) worst case

1381. Design a Stack With Increment Operation
class CustomStack:

    def __init__(self, maxSize: int):
        self.stack=[]
        self.maxSize = maxSize
    def push(self, x: int) -> None:
        if len(self.stack)<self.maxSize:
            self.stack.append(x)
    def pop(self) -> int:
        if self.stack:
            temp = self.stack[-1]
            self.stack=self.stack[:-1]
            return temp
        else:
            return -1

    def increment(self, k: int, val: int) -> None:
        if len(self.stack)<k:
            for i in range(len(self.stack)):
                self.stack[i]+=val
        else:
            for i in range(k):
                self.stack[i]+=val

# Your CustomStack object will be instantiated and called as such:
# obj = CustomStack(maxSize)
# obj.push(x)
# param_2 = obj.pop()
# obj.increment(k,val)


814. Binary Tree Pruning

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pruneTree(self, root: TreeNode) -> TreeNode:
        def containsOne(node):
            if not node:
                return False 
            case1 = containsOne(node.left)
            case2 = containsOne(node.right)
            if not case1: node.left=None
            if not case2: node.right=None
            
            return node.val==1 or case1 or case2
        
        return root if containsOne(root) else None
            
            
29. Divide Two Integers

class Solution:
    def divide(self, dividend: int, divisor: int) -> int:
        max_int = 2147483647
        min_int = -2147483648
  
        if dividend==min_int and divisor==-1:
            return max_int
  
        quotient=0
        negatives=2
        if dividend>0:
            negatives-=1
            dividend=-dividend
  
        if divisor>0:
            negatives-=1
            divisor=-divisor
    
        while dividend-divisor<=0:
            quotient-=1
            dividend-=divisor
  
        return -quotient if negatives!=1 else quotient
        
 8. String to Integer (atoi)

def stringToInteger(s):
  if len(s)==0:
    return 0 
  
  ls = list(s.strip())
  sign=-1 if ls[0]=='-' else 1
  if ls[0] in ['+','-']: del ls[0]
  i=0
  res=0
  while i<len(ls) and ls[i].isdigit():
    res = res*10 + ord(ls[i])-ord('0')
    i+=1  
  return max(-2**31, min(res*sign, 2**31))

print(stringToInteger("   -42"))

Time is O(n) and space is O(n)


402. Remove K Digits

class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
        stack=[]
        for i in num:
            while k>0 and len(stack)>0 and stack[-1]>i:
                stack.pop()
                k-=1
            stack.append(i)
        if k>0:
            stack = stack[:-k]
        return "".join(stack).lstrip("0") or "0"
  

523. Continuous Subarray Sum

class Solution:
    def checkSubarraySum(self, nums: List[int], k: int) -> bool:
        lookup={0:-1}
        total=0
        for i in range(len(nums)):
            if k!=0:
                total = (total + nums[i])%k
            else:
                total+= nums[i]
            
            if total not in lookup:
                lookup[total]=i
            else:
                if i-lookup[total]>=2:
                    return True
        return False 

179. Largest Number

from functools import cmp_to_key
class Solution:
    def largestNumber(self, nums: List[int]) -> str:
        def comp_function(x,y):
            if x+y>y+x:
                return 1
            elif x+y == y+x:
                return 0
            else:
                return -1
            
        
        nums=[str(i) for i in nums]
        nums.sort(key=cmp_to_key(comp_function), reverse=True)
        
        return ''.join(nums).lstrip('0') or '0'



402. Remove K Digits

class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
        stack=[]
        for i in num:
            while k>0 and len(stack)>0 and stack[-1]>i:
                k-=1
                stack.pop()
            
            stack.append(i)
        if k>0:
            stack=stack[:-k]
        
        return "".join(stack).lstrip('0') or "0"
        
        
130. Surrounded Regions
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        if not board:
            return 
        m,n=len(board),len(board[0])
        def dfs(i,j):
            directions=[(-1,0),(0,1),(1,0),(0,-1)]
            if 0<=i<len(board) and 0<=j<len(board[0]) and board[i][j]=='O':
                board[i][j]='N'
                for m,n in directions:
                    dfs(i+m,j+n)
        
        for i in range(m):
            if board[i][0]=="O": dfs(i,0)
            if board[i][n-1]=="O": dfs(i,n-1)
        
        for i in range(n):
            if board[0][i]=="O": dfs(0,i)
            if board[m-1][i]=="O": dfs(m-1,i)
        
        for i in range(m):
            for j in range(n):
                if board[i][j]!='N': board[i][j]='X'
                else:
                    board[i][j]='O'
                    
 5. Longest Palindromic Substring
class Solution:
    def longestPalindrome(self, s: str) -> str:
        res=''
        for i in range(len(s)):
            temp = self.helper(s,i,i)
            if len(temp)> len(res):
                res=temp
            
            temp = self.helper(s,i,i+1)
            if len(temp)>len(res):
                res=temp
        return res
    
    
    
    def helper(self,s,l,r):
        while l>=0 and r<len(s) and s[l]==s[r]:
            l-=1
            r+=1
        return s[l+1:r]
        

98. Validate Binary Search Tree
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        def helper(node, lower=float('-inf'), upper=float('inf')):
            if not node:
                return True
            val = node.val
            if val<=lower or val>=upper:
                return False
            if not helper(node.right, val,upper):
                return False
            if not helper(node.left,lower,val):
                return False
            return True
        
        return helper(root)
       
  
 1258. Synonymous Sentences
 
 class Solution:
    def generateSentences(self, synonyms: List[List[str]], text: str) -> List[str]:
        lookup = collections.defaultdict(dict)
        res = set()
        queue = collections.deque()
        queue.append(text)
        for i,j in synonyms:
            lookup[i][j]=1
            lookup[j][i]=1
        
        while queue:
            current = queue.popleft()
            res.add(current)
            words = current.split()
            for i,w in enumerate(words):
                if w in lookup.keys():
                    for newWord in lookup[w]:
                        newSent = " ".join(words[:i]+[newWord]+words[i+1:])
                        if newSent not in res:
                            queue.append(newSent)
        return sorted(list(res))
        
 151. Reverse Words in a String
 
class Solution:
    def reverseWords(self, s: str) -> str:
        s= [i for i in s]
        self.reverse(s,0,len(s)-1)
        previous =0 
        for i in range(len(s)):
            if s[i]==" ":
                self.reverse(s,previous,i-1)
                previous=i+1
            elif i == len(s)-1:
                self.reverse(s,previous,i)
        return "".join(s)
    def reverse(self, s,left, right):
        while left<right:
            s[left], s[right] = s[right],s[left]
            left+=1
            right-=1
            
841. Keys and Rooms

class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        seen =[False]* len(rooms)
        seen[0] = True
        stack=[0]
        while stack:
            cur= stack.pop()
            for room in rooms[cur]:
                if not seen[room]:
                    seen[room]=True
                    stack.append(room)
        return all(seen)
        

901. Online Stock Span

class StockSpanner:

    def __init__(self):
        self.stack=[]
        self.index =-1

    def next(self, price: int) -> int:
        self.index+=1
        while self.stack and self.stack[-1][1]<=price:
            self.stack.pop()
            
        if not self.stack:
            self.stack.append((self.index,price))
            return self.index+1
        temp = self.stack[-1][0]
        self.stack.append((self.index,price))
        return self.index - temp
# Your StockSpanner object will be instantiated and called as such:
# obj = StockSpanner()
# param_1 = obj.next(price)
        
515. Find Largest Value in Each Tree Row

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def largestValues(self, root: TreeNode) -> List[int]:
        if not root:
            return 
        queue= collections.deque([root])
        res=[]
        while queue:
            n = len(queue)
            temp=[]
            for _ in range(n):
                node = queue.popleft()
                temp.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
                
            res.append(max(temp))
        
        return res 

1011. Capacity To Ship Packages Within D Days

class Solution:
    def shipWithinDays(self, weights: List[int], D: int) -> int:
        low, high = max(weights), sum(weights)
        while low<high:
            mid = (low+high)//2
            cur_capacity = 0
            cur_ships =1
            
            for w in weights:
                cur_capacity+=w
                if cur_capacity>mid:
                    cur_capacity=w
                    cur_ships+=1
                
            if cur_ships>D:
                low=mid+1
            
            else:
                high = mid
            
        return low
        
Time is O(nlogn) and space is O(1)

529. Minesweeper
class Solution:
    def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:
        row,col = click[0],click[1]
        directions=[(-1,0),(0,-1),(1,0),(0,1),(-1,-1),(1,1),(1,-1),(-1,1)]
        if board[row][col]=="M":
            board[row][col]="X"
            return board
        
        else:
            count=0
            for m, n in directions:
                new_row = row+m
                new_col = col +n
                if not (0<=new_row<len(board) and 0<=new_col<len(board[0])):
                    continue
                if board[new_row][new_col]=="M":
                    count+=1
            if count:
                board[row][col]=str(count)
            
            else:
                board[row][col]="B"
                for m, n in directions:
                    new_row = row+m
                    new_col = col +n
                    if not (0<=new_row<len(board) and 0<=new_col<len(board[0])):
                        continue
                    if board[new_row][new_col]=="E":
                        self.updateBoard(board,(new_row,new_col))
        return board
   Time is O(mn) space is O(1)
   
   
