Linear Structure Basics
Includes: String, Array, Linked List

Difficulty Level: ( Easy | Medium ))



Must-Do
LeetCode88. Merge Sorted Array:--
        i=m-1
        k= len(nums1)-1
        j=n-1
        while i>=0 and j>=0:
          if nums1[i]<nums2[j]:
            nums1[k] = nums2[j]
            j-=1
            k-=1
          else:
            nums1[k]=nums1[i]
            i-=1
            k-=1
       nums1[:j+1] = nums2[:j+1]

LeetCode186. Reverse Words in a String 11
             
             1st i need to define a reverse function which takes list, left and right pointers
             2) revesrse the entire list using the function
             3) for loop over the list and check for empty space element and run the below function:
             self.reverse(s,0,len(s)-1) ===> reverses the list
             previous =0 
             for i in range(len(s)):
               if s[i]==" ":
                self.reverse(s,previous,i-1)
                previous=i+1
               elif s[i] == len(s)-1:
                self.reverse(s,previous,i)
             def reverse(self, s,left, right):
              while left<right:
                 s[left], s[right] = s[right],s[left]
                 left+=1
                 right-=1
            
              

LeetCode1. Two Sum
import collections
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        my_dict = {k:v for v,k in enumerate(nums)}
        for i in range(len(nums)):
            temp_res = target - nums[i]
            if temp_res in my_dict and my_dict[temp_res]!=i:
                return [i,my_dict[temp_res]]

LeetCode143. Reorder List

class Solution:
    def reorderList(self, head: ListNode) -> None:
        """
        Do not return anything, modify head in-place instead.
        """
        if not head:
            return
        fast=slow=head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        
        previous,cur = None, slow 
        while cur:
            cur.next,previous,cur = previous,cur,cur.next
        
        first,second = head,previous
        while second.next:
            first.next,first = second,first.next
            second.next,second = first,second.next

LeetCode92. Reverse Linked List II
 dummy=ListNode(0)
        dummy.next = head
        
        previous,cur= dummy,head
        for _ in range(m-1):
            cur= cur.next
            previous=previous.next
        for _ in range(n-m):
            temp=cur.next
            cur.next=temp.next
            temp.next=previous.next
            previous.next= temp
        return dummy.next
LeetCode56. Merge Intervals
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        sorted(intervals)
        res=[]
        for i in intervals:
            if not res or res[-1][1]<i[0]:
                res.append(i)
            else:
                res[-1][1]=max(res[-1][1],i[1])
        return res

LeetCode20. Valid Parentheses
class Solution:
    def isValid(self, s: str) -> bool:
        stack=[]
        my_dict = {"]":"[","}":"{",")":"("}
        for i in s:
            if i in my_dict:
                top_el = stack.pop() if stack else "#"
                if top_el != my_dict[i]:
                    return False
            else:
                stack.append(i)
        return not stack

LeetCode75. Sort Colors
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        red,white,blue = 0,0,len(nums)-1
        while white<=blue:
            if nums[white]==0:
                nums[red],nums[white]= nums[white],nums[red]
                red+=1
                white+=1
            elif nums[white]==1:
                white+=1
            else:
                nums[white],nums[blue]=nums[blue],nums[white]
                blue-=1
                
LeetCode155. Min Stack


class MinStack:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack=[]
        self.minStack=[]

    def push(self, x: int) -> None:
        self.stack.append(x)
        if not self.minStack or self.minStack[-1]>= x:
            self.minStack.append(x)
    def pop(self) -> None:
        temp= self.stack.pop()
        if temp == self.minStack[-1]:
            self.minStack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.minStack[-1]


# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(x)
# obj.pop()
# param_3 = obj.top()
#param_4 = obj.getMin()


LeetCode277. Find the Celebrity
class Solution:
    def findCelebrity(self, n: int):
        candidate=0
        for i in range(1,n):
            if knows(candidate,i):
                candidate=i
        for i in range(n):
            candidate_knows_i = knows(candidate,i)
            i_knows_cand= knows(i,candidate)
            if i!=candidate and (candidate_knows_i or not i_knows_cand):
                return -1
        return candidate

LeetCode281. Zigzag Iterator
class ZigzagIterator:
    def __init__(self, v1: List[int], v2: List[int]):
        self.queue = [_ for _ in (v1,v2) if _]

    def next(self) -> int:
        v=self.queue.pop(0)
        res=v.pop(0)
        if v:
            self.queue.append(v)
        return res
            
    def hasNext(self) -> bool:
        if self.queue:
            return True
        else:
            return False

57. insert interva
class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        if not intervals and newInterval:
            return [newInterval]
        i=0
        res=[]
        while i<len(intervals):
            if intervals[i][1]>= newInterval[0] and intervals[i][1]<= newInterval[1] :
                intervals[i][1] = max(intervals[i][1],newInterval[1])
                intervals[i][0] = min(intervals[i][0],newInterval[0])
                res.append([intervals[i][0],intervals[i][1]])
                newInterval=[float('inf'),float('inf')]
            else:
                res.append(intervals[i])
            i+=1
        if newInterval!=[float('inf'),float('inf')]:
            res.append(newInterval)
        res.sort()
        final_res=[res[0]]
        j=1
        while j<len(res):
            if final_res[-1][1]>=res[j][0]:
                final_res[-1][1]=max(final_res[-1][1],res[j][1])
            else:
                final_res.append(res[j])
            j+=1
        return final_res
71. Simplify Path

15. 3Sum
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        res = set()
        i =0
        nums.sort()
        while i<len(nums)-2:
            left,right=i+1,len(nums)-1
            while left<right:
                temp = nums[left]+nums[right]+nums[i]
                if temp>0:
                    right-=1
                elif temp<0:
                    left+=1
                else:
                    res.add((nums[left],nums[right],nums[i]))
                    left+=1
            i+=1
        return list(res)



Optional
LeetCode234. Palindrome Linked List

LeetCode283. Move Zeros

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        def swap(i,j):
            nums[i], nums[j]= nums[j],nums[i]
        i = 0
        j = 1
        while j<len(nums):
            if nums[i]==0 and nums[j]==0:
                j+=1
            elif nums[i]==0:
                swap(i,j)
                j+=1
                i+=1
            else:
                i =j 
                j=i+1
                

LeetCode242. Valid Anagram

import collections
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        s_res= collections.Counter(s)
        t_res = collections.Counter(t)
        
        key_set = set()
        for k in s_res.keys():
            key_set.add(k)
        for k in t_res.keys():
            key_set.add(k)
        for key in key_set:
            if s_res[key] != t_res[key]:
                return False
        
        return True

16. 3sum closest

class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        closest = nums[0] + nums[1] + nums[2]
        nums.sort()
        
        for i in range(len(nums)-2):
            l= i+1
            
            r= len(nums)-1
            
            while l<r:
                total = nums[i]+ nums[l] + nums[r]
                
                if abs(target-total) < abs(target - closest):
                    closest = total
                
                if total< target:
                    l+=1
                
                elif total > target:
                    r -=1
                else:
                    return closest
            
        return closest

246. Strobogrammatic Number



82. Remove Duplicates from Sorted list II

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        dummy = ListNode(-1)
        dummy.next = head
        
        l,r= dummy, dummy.next 
        
        while r:
            if r.next and r.val == r.next.val:
                val_remember = r.val
                
                while r and r.val==val_remember:
                    r = r.next
                
                l.next =r
            else:
                l, r = r, r.next
        
        return dummy.next
        
380. Insert delete getrandom O(1)

from random import choice
class RandomizedSet:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.lookup={}
        self.myList=[]

    def insert(self, val: int) -> bool:
        """
        Inserts a value to the set. Returns true if the set did not already contain the specified element.
        """
        if val not in self.lookup:
            self.lookup[val] = len(self.myList)
            self.myList.append(val)
            return True
        return False

    def remove(self, val: int) -> bool:
        """
        Removes a value from the set. Returns true if the set contained the specified element.
        """
        if val in self.lookup:
            last, idx = self.myList[-1], self.lookup[val]
            self.myList[idx] = last
            self.myList.pop()
            self.lookup[last]=idx
            del self.lookup[val]
            return True
        return False

    def getRandom(self) -> int:
        """
        Get a random element from the set.
        """
        return choice(self.myList)
        


# Your RandomizedSet object will be instantiated and called as such:
# obj = RandomizedSet()
# param_1 = obj.insert(val)
# param_2 = obj.remove(val)
# param_3 = obj.getRandom()

11 container with most water

189 rotate array

class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        temp_arr = nums[len(nums)-k::] + nums[0:((len(nums)-k))]
        for i in range(len(temp_arr)):
            nums[i] = temp_arr[i]

48 rotate image

class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        for i in range(len(matrix)):
            for j in range(i,len(matrix)):
                matrix[j][i], matrix[i][j]= matrix[i][j], matrix[j][i]
                
                
        
        for row in matrix:
            row=row.reverse()

225 implement stack using queues

import collections

class Queue:
    def __init__(self):
        self.q_ = collections.deque()
    def push(self,x):
        self.q_.append(x)
    def pop(self):
        return self.q_.popleft()
    def top(self):
        return self.q_[0]
    def size(self):
        return len(self.q_)
    def empty(self):
        return len(self.q_)==0 

class MyStack:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.stack = Queue()
        
    def push(self, x: int) -> None:
        """
        Push element x onto stack.
        """
        self.stack.push(x)
        for _ in range(self.stack.size() -1):
            self.stack.push(self.stack.pop())
    def pop(self) -> int:
        """
        Removes the element on top of the stack and returns that element.
        """
        return self.stack.pop()

    def top(self) -> int:
        """
        Get the top element.
        """
        return self.stack.top()

    def empty(self) -> bool:
        """
        Returns whether the stack is empty.
        """
        return self.stack.size()==0


# Your MyStack object will be instantiated and called as such:
# obj = MyStack()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.empty()






Linear Structure Advanced
Includes: String, Array, Linked List
Difficulty Level: ( Medium | Hard )


Must-Do
LeetCode259. 3Sum Smaller

class Solution:
    def threeSumSmaller(self, nums: List[int], target: int) -> int:
        count = 0 
        nums.sort()
        for i in range(len(nums)-2):
            l= i+1
            r= len(nums)-1
            
            while l<r:
                total = nums[i]+nums[l]+nums[r]
                
                if total<target:
                    count += r-l
                    l+=1
                else:
                    r-=1
        return count


LeetCode532. K-diff Pairs in an Array

LeetCode567. Permutation in String

LeetCode76. Minimum Window Substring

LeetCode85. Maximal Rectangle

LeetCode475. Heaters

LeetCode340. Longest Substring with At Most K Distinct Characters

LeetCode42. Trapping Rain Water



class Solution:
    def trap(self, height: List[int]) -> int:
        p,q = 0, len(height)-1
        lmax,rmax =0,0
        water =0
        while p<q:
            if height[p]<= height[q]:
                if height[p]> lmax:
                    lmax = height[p]
                else:
                    water = water + lmax - height[p]
                p+=1
            else:
                if height[q]>rmax:
                    rmax = height[q]
                else:
                    water += rmax - height[q]
                q-=1
        return water

LeetCode239. Sliding Window Maximum

LeetCode274. H-Index

LeetCode275. H-Index II

LC 26. Remove Duplicates from Sorted Array

class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums)>1:
            i = len(nums)-1
            while i>0:
                if nums[i]==nums[i-1]:
                    nums.pop(i)
                i-=1
        

LC 80. Remove Duplicates from Sorted Array II

LC 442. Find All Duplicates in an Array

class Solution:
    def findDuplicates(self, nums: List[int]) -> List[int]:

        res=[]
        for i in nums:
            if nums[abs(i)-1]<0:
                res.append(abs(i))
            else:
                nums[abs(i)-1] *=-1
        
        return res

LC 448. Find All Numbers Disappeared in an Array

class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        for i in range(len(nums)):
            new_index = abs(nums[i])-1
            if nums[new_index]>0:
                nums[new_index]*=-1  
        
        res=[]
        
        for i in range(1,len(nums)+1):
            if nums[i-1]>0:
                res.append(i)
        
        return res

LC 41. First Missing Positive

LC 268. Missing Number

class Solution:
    def missingNumber(self, nums):
        num_set = set(nums)
        n = len(nums) + 1
        for number in range(n):
            if number not in num_set:
                return number
                
LC 287. Find the Duplicate Number

import collections
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        count = collections.Counter(nums)
        
        for key in count.keys():
            if count[key]>=2:
                return key

LC 54 Spiral Matrix
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix:
            return []
        top=left=0
        right = len(matrix[0])-1
        bottom = len(matrix)-1
        res=[]
        while left<=right and top<=bottom:
            if left == right:
                for i in range(top,bottom+1):
                    res.append(matrix[i][left])
                break
            if top==bottom:
                for i in range(left,right+1):
                    res.append(matrix[top][i])
                break
            
            for i in range(left,right+1):
                res.append(matrix[top][i])
            
            for i in range(top+1,bottom+1):
                res.append(matrix[i][right])
            for i in reversed(range(left,right)):
                res.append(matrix[bottom][i])
            
            for i in reversed(range(top+1,bottom)):
                res.append(matrix[i][left])
            
            top+=1
            left+=1
            right-=1
            bottom-=1
        
        return res

84. Largest Rectangle in Histogram (H)

105 Construct Binary Tree from Preorder and Inorder Traversal





Optional
LeetCode658. Find K Closest Elements

LeetCode159. Longest Substring with At Most Two Distinct Characters

LC 316. Remove Duplicate Letters

LC 142. Linked List Cyle II

LC 224 Basic Calculator

LC 227 Basic Calculator II

LC 59 Spiral Matrix II






Recursion + Search  - Basic
Includes: Recursion + Binary Search + Tree
Difficulty Level: ( Easy | Medium )



Must-Do
206. Reverse Linked List

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseUtil(self,head,node):
        if not head:
            return node
        temp = head.next
        head.next = node
        return self.reverseUtil(temp,head)
    def reverseList(self, head: ListNode) -> ListNode:
        return self.reverseUtil(head,None)
        

LeetCode278. First Bad Version

# The isBadVersion API is already defined for you.
# @param version, an integer
# @return an integer
# def isBadVersion(version):

class Solution:
    def firstBadVersion(self, n):
        """
        :type n: int
        :rtype: int
        """
        start =0 
        end = n 
        
        while start +1 < end:
            mid = start + (end -start)//2
            
            if isBadVersion(mid):
                end = mid
            else:
                start = mid
                
        return end


LeetCode34. Search for a Range

class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        def search(n):
            l,r = 0, len(nums)
            while l<r:
                mid = l+(r-l)//2
                if nums[mid]>=n:
                    r = mid
                else:
                    l=mid+1
            return l
                    
        start = search(target)
        
        return [start, search(target+1)-1] if target in nums[start : start+1] else [-1,-1]


LeetCode450. Delete Node in a BST

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    
    def successor(self,root):
        root = root.right
        while root.left:
            root=root.left

        return root.val 
        
    def predecessor(self,root):
        root = root.left
        while root.right:
            root = root.right

        return root.val
    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
        
        
        
        if not root:
            return None 
        
        if key > root.val:
            root.right = self.deleteNode(root.right,key)
        
        elif key < root.val:
            root.left = self.deleteNode(root.left,key)
        
        else:
            if not root.left and not root.right:
                root= None
            
            elif root.right:
                root.val = self.successor(root)
                root.right = self.deleteNode(root.right,root.val)
            else:
                root.val = self.predecessor(root)
                root.left = self.deleteNode(root.left,root.val)
        
        return root
            


LeetCode156. Binary Tree Upside Down

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def upsideDownBinaryTree(self, root: TreeNode) -> TreeNode:
        if not root or (not root.left and not root.right):
            return root 
        lroot = self.upsideDownBinaryTree(root.left)
        
        temp = lroot
        while temp.right:
            temp=temp.right
        
        temp.right = TreeNode(root.val)
        temp.left= root.right
        return lroot

LeetCode98. Validate Binary Search Tree

        res=[]
        def inOrder(root):
            if not root:
                return None
            left = inOrder(root.left)
            res.append(root.val)
            right = inOrder(root.right)
        inOrder(root)
        for i in range(1,(len(res))):
            if res[i]<=res[i-1]:
                return False
        return True
        
        ----------
        Recursive
        # Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        return self.helper(root)
    
    def helper (self,node,lower=float('-inf'),upper=float('inf')):
        if not node:
            return True
        val = node.val
        if val<=lower or val>=upper:
            return False
        if not self.helper(node.left,lower,val):
            return False
        if not self.helper(node.right,val,upper):
            return False
        return True
                    



Lowest Common Ancestor of a Binary Tree

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if p == root or q == root:
            return root
        
        
        left=right=None 
        if root.left:
            left = self.lowestCommonAncestor(root.left,p,q)
        if root.right:
            right = self.lowestCommonAncestor(root.right,p,q)
        
        if left and right:
            return root
    
        
        return left or right

LeetCode153. Find Minimum in Rotated Sorted Array

class Solution:
    def findMin(self, nums: List[int]) -> int:
        l,r = 0, len(nums)-1
        while l<r and nums[l]>=nums[r]:
            mid = (l+r)//2
            if nums[mid]<nums[l]:
                r=mid
            else:
                l = mid +1
        return nums[l]

LeetCode154. Find Minimum in Rotated Sorted Array II

def findMin(nums):
    l,r = 0, len(nums)-1
    # [2,3,4,5,6,7] => [5,6,7,2,2,3,3,4,4]
                              
    while l<r:
        mid = (l+r)//2
        if nums[mid]>nums[r]:
            l= mid +1
        elif nums[mid]<nums[r]:
            r= mid
        else:
            r-=1
    return nums[l]

LeetCode144. Binary Tree Preorder Traversal

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        def dfs(root,res):
            if root:
                res.append(root.val)
                dfs(root.left,res)
                dfs(root.right,res)
                
        res=[]
        dfs(root,res)
        return res

104. Maximum Depth of Binary Tree

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        
        left = self.maxDepth(root.left)
        right = self.maxDepth(root.right)
        
        return 1 + max(left,right)

111. Minimum Depth of Binary Tree

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        if root.left and root.right:
            left = self.minDepth(root.left)
            right = self.minDepth(root.right)
            
            return 1 + min(left,right)
        
        elif  root.left:
            return 1 + self.minDepth(root.left)
        
        else:  
            return 1 + self.minDepth(root.right)

257. Binary Tree Paths

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        def construct_paths(root,path):
            if root:
                path+=str(root.val)
                if not root.left and not root.right:
                    paths.append(path)
                else:
                    path+="->"
                    construct_paths(root.left,path)
                    construct_paths(root.right,path)
        
        
        paths=[]
        construct_paths(root,'')
        
        return paths
        
        
101. Symmetric Tree

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def search(self,p,q):
        if not p and not q:
            return True
        if not p or not q or p.val != q.val:
            return False
        return self.search(p.left,q.right) and self.search(p.right, q.left)
    def isSymmetric(self, root: TreeNode) -> bool:
        return self.search(root.left, root.right) if root else True

110. Balanced Binary Tree

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def lookup(self,root):
        if not root:
            return 0 
        left_height, right_height = self.lookup(root.left),self.lookup(root.right)
        if left_height<0 or right_height<0 or abs(left_height-right_height)>1:
            return -1
        return max(left_height,right_height)+1
    def isBalanced(self, root: TreeNode) -> bool:
        return self.lookup(root)>=0





Optional
LeetCode235. Lowest Common Ancestor of a Binary Search Tree

LeetCode33. Search in Rotated Sorted Array

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        if not nums:
            return -1
        
        left,right = 0, len(nums)-1
        while left+1<right:
            mid = left +(right-left)//2
            if nums[mid]==target:
                return mid
            elif nums[left]<= nums[mid]:
                if nums[left]<=target and target<nums[mid]:
                    right=mid
                else:
                    left=mid
            else:
                if target<=nums[right] and target>nums[mid]:
                    left=mid
                else:
                    right=mid
                    
        if nums[left]==target:
            return left
        if nums[right]==target:
            return right
        return -1
            

LeetCode94. Binary Tree Inorder Traversal

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        def inorder(root, res):
            if root:
                inorder(root.left,res)
                res.append(root.val)
                inorder(root.right,res)
        
        res=[]
        inorder(root,res)
        
        return res

LeetCode145. Binary Tree Postorder Traversal

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        def utils(root,res):
            if root:
                utils(root.left,res)
                utils(root.right,res)
                res.append(root.val)
        
        res=[]
        utils(root,res)
        
        return res

LeetCode102. Binary Tree Level Order Traversal

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        res=[]
        
        queue = [root]
        
        while queue:
            temp_list =[]
            for _ in range(len(queue)):
                cur_node = queue.pop(0)
                temp_list.append(cur_node.val)
                if cur_node.left:
                    queue.append(cur_node.left)
                if cur_node.right:
                    queue.append(cur_node.right)
            res.append(temp_list)
        return res

LeetCode81. Search in Rotated Sorted Array II

class Solution:
    def search(self, nums: List[int], target: int) -> bool:
        l,r=0,len(nums)-1
        while l<=r:
            mid = (l+r)//2
            if nums[mid]==target:
                return True
            elif nums[l]==nums[mid]:
                l+=1
            elif (nums[mid]> nums[l] and nums[l]<=target<nums[mid]) or (nums[mid]<nums[l] and not (nums[mid]<target<=nums[r])):
                r= mid-1
            else:
                l=mid+1
        return False

129. Sum Root to Leaf Numbers

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:        
    def sumNumbers(self, root: TreeNode) -> int:
        
        if not root:
            return 0 
        
        if not root.left and not root.right:
            return int(root.val)
        
        if root.left: root.left.val = 10*(root.val) + root.left.val
        if root.right: root.right.val = 10*(root.val) + root.right.val
        
        return self.sumNumbers(root.left) + self.sumNumbers(root.right)






Recursion + Search  - Advanced
Includes: Recursion + Binary Search + Tree
Difficulty Level: ( Medium | Hard )


Must-Do
LeetCode772. Basic Calculator III

LeetCode255. Verify Preorder Sequence in Binary Search Tree

LeetCode105. Construct Binary Tree from Preorder and Inorder Traversal

LeetCode436. Find Right Interval

LeetCode315. Count of Smaller Numbers After Self

LeetCode208. Implement trie tree
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.head={}

    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self.head
        for ch in word:
            if ch not in cur:
                cur[ch]={}
            cur= cur[ch]
        cur["*"]= True
    def search(self, word: str) -> bool:
        """
        Returns if the word is in the trie.
        """
        cur = self.head
        for ch in word:
            if ch not in cur:
                return False
            cur= cur[ch]
        if "*" in cur:
            return True
        else:
            return False
    def startsWith(self, prefix: str) -> bool:
        """
        Returns if there is any word in the trie that starts with the given prefix.
        """
        cur = self.head
        for ch in prefix:
            if ch not in cur:
                return False
            cur= cur[ch]
        return True
        


# Your Trie object will be instantiated and called as such:
# obj = Trie()
# obj.insert(word)
# param_2 = obj.search(word)
# param_3 = obj.startsWith(prefix)
LeetCode29. Divide Two Integers

LeetCode307. Range Sum Query - Mutable

LeetCode4. Median of Two Sorted Arrays

LeetCode297. Serialize and Deserialize Binary Tree

LeetCode776. Split BST

LeetCode114. Flatten Binary Tree to Linked List

LeetCode298. Binary Tree Longest Consecutive Sequence

LeetCode99. Recover Binary Search Tree

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def recoverTree(self, root: TreeNode) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        def inorder(root):
            return inorder(root.left) + [root.val]+ inorder(root.right) if root else []
        
        def getSwap(nums):
            n=len(nums)
            x=y=-1
            for i in range(n-1):
                if nums[i+1]<nums[i]:
                    y= nums[i+1]
                    if x==-1:
                        x=nums[i]
                    else:
                        break
            return x,y
        
        def recover(r:TreeNode,count):
            if r:
                if r.val ==x or r.val ==y:
                    r.val=y if r.val==x else x
                    count-=1
                    if count ==0:
                        return 
                recover(r.left,count)
                recover(r.right,count)
            
        nums =inorder(root)
        x,y = getSwap(nums)
        recover(root,2)
        

QuickSort implementation

LeetCode384. Shuffle an Array

import random
class Solution:

    def __init__(self, nums: List[int]):
        self.nums = nums

    def reset(self) -> List[int]:
        """
        Resets the array to its original configuration and return it.
        """
        return self.nums 

    def shuffle(self) -> List[int]:
        """
        Returns a random shuffling of the array.
        """
        self.res = self.nums[:] 
        for i in range(len(self.res)-1,0,-1):
            j = random.randrange(i+1)
            self.res[i],self.res[j] = self.res[j],self.res[i]
        
        return self.res
        


# Your Solution object will be instantiated and called as such:
# obj = Solution(nums)
# param_1 = obj.reset()
# param_2 = obj.shuffle()

LeetCode378. Kth Smallest Element in a Sorted Matrix

LeetCode74 Search in 2D Matrix

LeetCode240 Search in 2D Matrix II





Optional
LeetCode303. Range Sum Query

LeetCode261. Graph Valid Tree

LeetCode230. Kth Smallest Element in a BST

LeetCode103. Binary Tree Zigzag Level Order Traversal

LeetCode367. Valid Perfect Square

LeetCode508. Most Frequent Subtree Sum

LeetCode250. Count Univalue Subtrees






Sorting | Graph  - Basic
Includes: Sorting | Graph | DFS | BFS
Difficulty Level: ( Easy | Medium )


Must-Do
75. Sort Colors

class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        l=cur=0
        r = len(nums)-1
        
        while cur<=r:
            if nums[cur]==0:
                nums[l], nums[cur] = nums[cur], nums[l]
                l+=1
                cur+=1
            elif nums[cur]==2:
                nums[r],nums[cur]=nums[cur],nums[r]
                r-=1
            else:
                cur+=1


LeetCode133. Clone Graph



LeetCode207. Course Schedule



LeetCode210. Course Schedule II

class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        
        in_degree = collections.defaultdict(set)
        out_degree = collections.defaultdict(set)
        
        for i,j in prerequisites:
            in_degree[i].add(j)
            out_degree[j].add(i)
            
        stack =[i for i in range(numCourses) if i not in in_degree]
        res =[]
        while stack:
            course = stack.pop()
            res.append(course)
            for i in out_degree[course]:
                in_degree[i].remove(course)
                if not in_degree[i]:
                    stack.append(i)
                    del in_degree[i]
            del out_degree[course]
        return res if not in_degree and not out_degree else []
        

LeetCode490. The Maze



LeetCode505. The Maze II



LeetCode46. Permutations

Time and space complexity is O(NN!)
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res=[]
        self.dfs(nums,[],res)
        return res
    
    def dfs(self,ds,fixed_path,res):
        if not ds:
            res.append(fixed_path)
            return
        
        for i in range(len(ds)):
            self.dfs(ds[:i]+ds[i+1:],fixed_path+[ds[i]],res)

LeetCode47. Permutations II



LeetCode200. Number of Islands

class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid:
            return 0
        count=0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j]=="1":
                    self.is_island(grid,i,j)
                    count+=1
        return count 
    
    def is_island(self,grid,i,j):
        if not (0<=i<len(grid) and 0<=j<len(grid[0])) or grid[i][j]=='visited' or grid[i][j]!="1":
            return    
        directions =[(-1,0),(0,1),(1,0),(0,-1)]
        for m,n in directions:
                grid[i][j]='visited'
                self.is_island(grid,i+m,j+n)
                

LeetCode305. Number of Islands II



692. Top K Frequent Words

class Solution:
    def topKFrequent(self, words: List[str], k: int) -> List[str]:
        lookup = collections.Counter(words)
        heap =[(-val,key) for key,val in lookup.items()]
        heapq.heapify(heap)
        res=[]
        for _ in range(k):
            res.append(heapq.heappop(heap)[1])
        return res



LeetCode286. Walls and Gates



LC 77 Combinations



LC 78 Subsets



52. N-Queens II





Optional
22. Generate Parentheses

LeetCode787. Cheapest Flights Within K Stops

499. The Maze III

222. Count Complete Tree Nodes

347. Top K Frequent Elements

class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        lookup = collections.Counter(nums)
        keys = list(lookup.keys())
        values = list(lookup.values())
        res =[]
        for _ in range(k):
            max_val = max(values)
            ind_max = values.index(max_val)
            res.append(keys[ind_max])
            keys.pop(ind_max)
            values.pop(ind_max)
        return res

295. Find Median from Data Stream

class solution:
        def __init__(self):
                self.small=[]
                self.large=[]
       def add(self,num):
        if len(self.small) == len(self.large):
               heappush(self.large, -heappushpop(self.small ,-num))
        else:
               heappush(self.small, -heappushpop(self.large,num))
       def findMedian(self):
        if len(self.large) == len(self.small):
                return float(self.large[0]-self.small[0])/2.0
        else:
                return float(self.large[0])
                
261. Graph Valid Tree

253. Meeting Room II

207. Course Schedule

339. Nested List Weight Sum

23. Merge k Sorted Lists

199. Binary Tree Right Side View

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rightSideView(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        queue =[root]
        res=[]
        while queue:
            temp_list =[]
            for _ in range(len(queue)):
                cur_node = queue.pop(0)
                temp_list.append(cur_node.val)
                if cur_node.left:
                    queue.append(cur_node.left)
                
                if cur_node.right:
                    queue.append(cur_node.right)
            
            res.append(temp_list[-1])
        
        return res 

90. Subset II

301. Remove invalid parentheses(DFS & BFS)



Sorting | Graph  - Advanced
Includes: Sorting | Graph | DFS | BFS
Difficulty Level: ( Medium | Hard )


Must-Do
LeetCode74. Search in 2D Matrix

class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        rows = len(matrix)
        if rows==0:
            return False
        cols = len(matrix[0])
        l,r= 0, rows*cols-1
        while l<=r:
            mid = l +(r-l)//2
            mid_element = matrix[mid//cols][mid%cols]
            if mid_element == target:
                return True
            else:
                if mid_element<target:
                    l+=1
                else:
                    r-=1
        return False
            

LeetCode240. Search in 2D Matrix II


LeetCode127. Word Ladder

O(m**2 x n) 

from collections import defaultdict
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        if endWord not in wordList or not endWord or not beginWord or not wordList:
            return 0

        # Since all words are of same length.
        L = len(beginWord)

        # Dictionary to hold combination of words that can be formed,
        # from any given word. By changing one letter at a time.
        all_combo_dict = defaultdict(list)
        for word in wordList:
            for i in range(L):
                # Key is the generic word
                # Value is a list of words which have the same intermediate generic word.
                all_combo_dict[word[:i] + "*" + word[i+1:]].append(word)
                print(all_combo_dict)
        # Queue for BFS
        queue = collections.deque([(beginWord, 1)])
        # Visited to make sure we don't repeat processing same word.
        visited = {beginWord: True}
        while queue:
            current_word, level = queue.popleft()      
            for i in range(L):
                # Intermediate words for current word
                intermediate_word = current_word[:i] + "*" + current_word[i+1:]

                # Next states are all the words which share the same intermediate state.
                for word in all_combo_dict[intermediate_word]:
                    # If at any point if we find what we are looking for
                    # i.e. the end word - we can return with the answer.
                    if word == endWord:
                        return level + 1
                    # Otherwise, add it to the BFS Queue. Also mark it visited
                    if word not in visited:
                        visited[word] = True
                        queue.append((word, level + 1))
        return 0

LeetCode126. Word Ladder II

LeetCode286. Walls and Gates

import collections
class Solution:
    def wallsAndGates(self, rooms: List[List[int]]) -> None:
        """
        Do not return anything, modify rooms in-place instead.
        """
        if not rooms:
            return []
        rows = len(rooms)
        cols = len(rooms[0])
        queue = collections.deque()
        for i in range(rows):
            for j in range(cols):
                if rooms[i][j] ==0:
                    queue.append((i,j))
        
        while queue:
            x,y = queue.popleft()
            
            for i,j in [(1,0),(0,-1),(0,1),(-1,0)]:
                if 0<=x+i<rows and 0<=y+j<cols and rooms[x+i][y+j]>rooms[x][y]:
                    rooms[x+i][y+j] = rooms[x][y] + 1
                    queue.append((x+i,y+j))

LeetCode305. Number of Island II

LeetCode323. Number of Connected Components in an Undirected Graph

Time: O(n+m), where m is the number of connections, n is the number of nodes.
Space: O(n+m)

class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        
        def dfs(lookup,i, seen):
            if i in seen:
                return
            seen.add(i)
            for j in lookup[i]:
                dfs(lookup,j,seen)
        lookup = {i:[] for i in range(n)}
        for i,j in edges:
            lookup[i].append(j)
            lookup[j].append(i)
        seen = set()
        res=0
        for i in range(n):
            if i not in seen:
                dfs(lookup,i,seen)
                res+=1
        return res
    

LeetCode353. SNAKE

LeetCode269. Alien Dictionary

LeetCode417. Pacific Atlantic Water Flow

LeetCode773. Sliding Puzzle

LeetCode547. Friend Circles

class Solution:
    def findCircleNum(self, M: List[List[int]]) -> int:
        n= len(M)
        seen= set()
        res=0
        def dfs(i):
            for j,adj in enumerate(M[i]):
                if adj and j not in seen:
                    seen.add(j)
                    dfs(j)
        for i in range(n):
            if i not in seen:
                dfs(i)
                res+=1
        return res

LeetCode425. Word Squares

LeetCode444. Sequence Reconstruction

LeetCode373. Find K Pairs with Smallest Sums

LeetCode45. Jump Game II




Optional
LeetCode785. Is Graph Bipartite

LeetCode839. Similar String Groups

LeetCode352. Data Stream as Disjoint Intervals

LeetCode973. Kth Closest Points

class Solution:
    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:
        points.sort(key= lambda p: p[0]**2 + p[1]**2)
        return points[:K]
    
LeetCode684. Redundant Connection

LeetCode802. Find Eventual Safe States

LeetCode737. Sentence Similarity II

LeetCode317. Shortest Distance from All Buildings

LeetCode399. Evaluate Division







Memorization | DP  - Basic
Includes: Sorting | Graph | DFS | BFS
Difficulty Level: ( Easy | Medium )


Must-Do
LeetCode198. House Robber

class Solution:
    def rob(self, nums: List[int]) -> int:
        n= len(nums)
        if n==0:
            return 0 
        dp = [0]*n
        dp[n-1]= nums[n-1]
        dp[n-2]=max(nums[n-1],nums[n-2])
        
        for i in range(n-3,-1,-1):
            dp[i]= max(nums[i]+dp[i+2], dp[i+1])
        
        return dp[0]

LeetCode213. House Robber II

class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 0: return 0
        if len(nums) == 1: return nums[0]
        if len(nums) == 2: return max(nums)
        def rob_helper(nums):
            n= len(nums)
            if n==0:
                return 0 
            dp = [0]*n
            dp[n-1]= nums[n-1]
            dp[n-2]=max(nums[n-1],nums[n-2])

            for i in range(n-3,-1,-1):
                dp[i]= max(nums[i]+dp[i+2], dp[i+1])
            return dp[0]
        return max(rob_helper(nums[:-1]), rob_helper(nums[1:]))

63. Unique Paths II

class Solution:
Time and space is O(mn)
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        rows = len(obstacleGrid)
        if rows ==0:
            return -1
        cols = len(obstacleGrid[0])
        dp =[[0]*cols for _ in range(rows)]
        for i in range(cols):
            if obstacleGrid[0][i] ==1:
                break
            dp[0][i]=1
        
        for i in range(rows):
            if obstacleGrid[i][0] ==1:
                break
            dp[i][0]=1
        
        for i in range(1,rows):
            for j in range(1,cols):
                if obstacleGrid[i][j]==1:
                    continue
                else:
                    dp[i][j]= dp[i][j-1] + dp[i-1][j]
        return dp[-1][-1]
        

LeetCode322. Coin Change


LeetCode518. Coin Change II

39. Combination Sum
Time is O(N **T/M+1) space O(T/M)
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res=[]
        def dfs(remain,comb,start):
            # //base case
            if remain==0:
                res.append(list(comb))
                return 
            if remain<0:
                return 
            for i in range(start,len(candidates)):
                comb.append(candidates[i])
                dfs(remain-candidates[i],comb,i)
                comb.pop()
        dfs(target,[],0)
        return res 

40. Combination Sum II

377. Combination Sum IV

72. Edit Distance

403. Frog Jump

309. Best Time to Buy and Sell Stock with Cooldown

LeetCode53. Maximum Subarray

class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        cur_max = global_max = nums[0]
        for i in range(1,len(nums)):
            cur_max = max(nums[i], cur_max+nums[i])
            if cur_max > global_max:
                global_max = cur_max 
        return global_max
                    

LeetCode486. Predict the Winner =Pot of Gold Game

LeetCode139. Word Break

LeetCode300. Longest Increasing Subsequence

LeetCode152. Maximum Product Subarray





Optional
542 01 matrix

LeetCode.10 Regular Expression Matching

LeetCode.64 Minimum Path Sum

class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        for i in range(1,len(grid[0])):
            grid[0][i]+=grid[0][i-1]
        for i in range(1,len(grid[1])):
            grid[i][0]+=grid[i-1][0]
        for i in range(1,len(grid)):
            for j in range(1,len(grid[0])):
                grid[i][j]=grid[i][j]+min(grid[i-1][j],grid[i][j-1])
        return grid[-1][-1]
        
        
LeetCode.291 Word Pattern II

LeetCode.79 word search

class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        if len(board)==0:
            return False
        if len(word)==0:
            return False
        for i in range(len(board)):
            for j in range(len(board[0])):
                
                if self.exists_helper(board,i,j,word,0):
                    return True
                
        return False
        
    def exists_helper(self,board,i,j,word,index):
        directions = [(-1,0),(0,-1),(1,0),(0,1)]
        if len(word)==index:
            return True

        if 0<=i<len(board) and 0<=j<len(board[0]) and board[i][j]!='visited' and board[i][j]== word[index]:
            board[i][j] = 'visited'
            res = False

            for m,n in directions:
                res = res or self.exists_helper(board,i+m,j+n,word,index+1)
            board[i][j] = word[index]
            return res
        
                

216. Combination Sum III

O(k) space and time is 9!k/(9-k)! .K 

class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        res=[]
        def dfs(ds,k,n,path):
            if k<0 or n<0:
                return 
            if k==0 and n==0:
                res.append(path)
            for i in range(len(ds)):
                dfs(ds[i+1:],k-1,n-ds[i],path+[ds[i]])
        
        dfs(list(range(1,10)),k,n,[])
        return res

70. Climbing Stairs

LeetCode279. Perfect Squares

LeetCode673. Number of Longest Increasing Subsequence

LeetCode140. Word Break II





Memorization | DP  - Advanced
Includes: Sorting | Graph | DFS | BFS
Difficulty Level: ( Medium | Hard )


Must-Do
LeetCode801. Minimum Swaps To Make Sequences Increasing

LeetCode790. Domino and Tromino Tiling

LeetCode764. Largest Plus Sign

LeetCode750. Number Of Corner Rectangles

LeetCode413. Arithmetic Slices
Time is O(n) and space is O(1)

class Solution:
    def numberOfArithmeticSlices(self, A: List[int]) -> int:
        dp=[0]*len(A)
        res = 0
        for i in range(2,len(A)):
            if A[i]-A[i-1] == A[i-1]-A[i-2]:
                dp[i]= dp[i-1]+1
                res+= dp[i]
            
        return res 

LeetCode446. Arithmetic Slices II - Subsequence



LeetCode132. Palindrome Partitioning II

LeetCode91. Decode Ways

class Solution:
    def __init__(self):
        self.mem ={}
    
    def recurse(self,s,index):
        if index == len(s):
            return 1
        if s[index]==0:
            return 0
        if index == len(s)-1:
            return 1
        if index in self.mem:
            return self.mem[index]
        ans = self.recurse(s,index+1) + (self.recurse(s,index+2) if (int(s[index: index+2])<=26) else 0)
        self.mem[index]= ans 
        return ans
        
    def numDecodings(self, s: str) -> int:
        if not s:
            return 0
        return self.recurse(s,0)
        
LeetCode639. Decode Ways II

LeetCode354. Russian Doll Envelopes

LC 32. Longest Valid Parentheses

LC 55. Jump Game
O(n)

class Solution:
    def canJump(self, nums: List[int]) -> bool:
        length = len(nums)
        last_index = length -1
        i = length -1
        while i>=0:
            if nums[i]+i>=last_index:
                last_index=i
            i-=1
            if last_index ==0:
                return True
        return False
        
LC 375. Guess Number Higher or Lower II



LC 363. Max Sum of Rectangle No Larger Than K

LC 44. Wildcard Matching



Optional
LC337. House Robber III

LC525. Contiguous Array

LC174. Dungeon Game

LC410. split array largest sum

LC5. Longest Palindromic Substring

LC516. Longest Palindromic Subsequence

class Solution:
    def longestPalindrome(self, s: str) -> str:
        res=''
        for i in range(len(s)):
            palin1= self.helper(s,i,i)
            palin2= self.helper(s,i,i+1)
            res = max(res,palin1,palin2,key=len)
        return res
    def helper(self,s,l,r):
        while l>=0 and r<len(s) and s[l]==s[r]:
            l-=1
            r+=1
        return s[l+1:r]

LC312. burst ballons

LC212. Word Pattern II

LC 464. Can I Win

LeetCode787. Cheapest Flights Within K Stops

LC95. Unique Binary Search Trees II

LC96. Unique Binary Search Trees

LC97. Interleaving String

LC135. Candy

LC329. Longest Increasing Path in Matrix







Amazon
~~~~~~~~~~

632. Smallest Range Covering Elements from K Lists

Time Complexity is O(nlogm)

class Solution:
    def smallestRange(self, nums: List[List[int]]) -> List[int]:
        heap=[]
        rangeStart=0
        range_end = float('inf')
        current_max = float('-inf')
        
        for i in range(len(nums)):
            heapq.heappush(heap,(nums[i][0],0,i))
            current_max = max(current_max, nums[i][0])
        
        while len(heap)==len(nums):
            num,idx,row = heapq.heappop(heap)
            if range_end - rangeStart >  current_max - num:
                rangeStart = num 
                range_end = current_max
            
            if idx+1< len(nums[row]):
                heapq.heappush(heap,(nums[row][idx+1],idx+1,row))
                current_max = max(current_max,nums[row][idx+1])
                
        return [rangeStart,range_end]
        
   
   
733. Flood Fill 

import collections
class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
        if image[sr][sc]== newColor:
            return image
        queue = collections.deque([(sr,sc)])
        color = image[sr][sc]
        visited={(sr,sc)}
        while queue:
            
            cur_r, cur_c = queue.popleft()
            image[cur_r][cur_c]=newColor
            for i,j in [(1,0),(-1,0),(0,-1),(0,1)]:
                new_r = cur_r+i 
                new_c = cur_c+j 
                
                if 0<= new_r<len(image) and 0 <= new_c<len(image[0]) and image[new_r][new_c]==color:
                    if (new_r,new_c) not in visited:
                        visited.add((new_r,new_c))
                        queue.append((new_r,new_c))
        
        return image
                    

1197. Minimum Knight Moves

import collections
class Solution:
    def minKnightMoves(self, x: int, y: int) -> int:
        queue = collections.deque([])
        queue.append((0,0,0))
        visited = {(0,0)}
        while queue:
            i,j,steps = queue.popleft()
            if i ==x and j==y:
                return steps
            
            directions = [(-2,-1),(-2,1),(2,1),(2,-1),(-1,2),(-1,-2),(1,2),(1,-2)]
            for m,n in directions:
                new_row = i+m
                new_col = j+n
                if (new_row, new_col) not in visited:
                    visited.add((new_row, new_col))
                    queue.append((new_row, new_col, steps+1))
        return -1
        
        
   78. Subsets
   
   class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res=[[]]
        for num in nums:
            res+=[i+[num] for i in res]
        return res
        
   subset for chars:
   def getSubStrings(string):
          str_list=[i for i in string]
          res=['']
          for ch in str_list:
            res+=[i+ch for i in res]
          return sorted(res[1:])

print(getSubStrings('abc'))
    
   90. Subsets II
   
   class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        res = [[]]
        nums.sort()
        for num in nums:
            res+=[i+[num] for i in res]
        lookup = {}
        for i in res:
            lookup[str(i)]=0
        res=[]
        for key in lookup.keys():
            res.append(eval(key))
        return res

1315. Sum of Nodes with Even-Valued Grandparent

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sumEvenGrandparent(self, root: TreeNode) -> int:
        def dfs(node,parent,grandparent):
            if not node:
                return
            nonlocal answer
            if parent and grandparent and grandparent.val%2==0:
                answer+=node.val
            dfs(node.left,node,parent)
            dfs(node.right,node,parent)
                
        answer=0
        dfs(root,None,None)
        return answer 

1395. Count Number of Teams

class Solution:
    def numTeams(self, rating: List[int]) -> int:
        n = len(rating)
        
        up = [0] * n
        down = [0] * n
        
        teams = 0
        
        for i in range(n-1, -1, -1):
            for j in range(i+1, n):
                if rating[i] < rating[j]:
                    up[i] += 1
                    teams += up[j]
                else:
                    down[i] += 1
                    teams += down[j]
        
        return teams


1038. Binary Search Tree to Greater Sum Tree

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    val=0
    def bstToGst(self, root: TreeNode) -> TreeNode:
        if root.right:
            self.bstToGst(root.right)
        root.val = self.val = self.val+root.val
        if root.left:
            self.bstToGst(root.left)
        return root


535. Encode and Decode TinyURL

from hashlib import sha256
import unittest
class TinyUrl:
  def __init__(self):
    self.lookup ={}
  
  def encode(self,long_url):
    key_set = sha256(long_url.encode()).hexdigest()[:6]
    tiny_url = "http://tinyurl.com/"+key_set
    self.lookup[tiny_url]=long_url
    return tiny_url
  
  
  def decode(self,tiny_url):
    return self.lookup[tiny_url]
  

obj = TinyUrl()
print(obj.encode("https://leetcode.com/problems/design-tinyurl"))
print(obj.decode("http://tinyurl.com/f86ef1"))




797. All Paths From Source to Target


import collections
def allPathsFromSourceToTarget(graph):
  n= len(graph)
  target = n-1
  result =[]
  
  def dfs(cur_node,path):
    #base case
    if cur_node == target:
      result.append(list(path))
      return
    
    for neighbour in graph[cur_node]:
      path.append(neighbour)
      dfs(neighbour,path)
      path.pop()
  
  path= collections.deque([0])
  dfs(0,path)
  return result

print(allPathsFromSourceToTarget([[1,2],[3],[3],[]]))

Time complexity and space complexity is 2**N *N where 
N is no. of nodes in the graph


1008. Construct Binary Search Tree from Preorder Traversal

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:
        def helper(lower=float('-inf'),high=float('inf')):
            nonlocal idx
            if idx == len(preorder):
                return None
            val = preorder[idx]
            if val<lower or val> high:
                return None
            root = TreeNode(val)
            idx+=1
            root.left = helper(lower,val)
            root.right = helper(val,high)

            return root
        idx=0
        return helper()

Time and space complexity is O(n)


1325. Delete Leaves With a Given Value

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def removeLeafNodes(self, root: TreeNode, target: int) -> TreeNode:
        if root:
            root.left = self.removeLeafNodes(root.left,target)
            root.right = self.removeLeafNodes(root.right,target)
            if root.val!=target or root.left or root.right:
                return root

701. Insert into a Binary Search Tree

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:
        if not root:
            return TreeNode(val)
        
        if val<root.val:
            root.left = self.insertIntoBST(root.left,val)
        else:
            root.right = self.insertIntoBST(root.right,val)
        
        return root
Time complexity is O(H) => O(log n) average case and O(N) worst case

1381. Design a Stack With Increment Operation
class CustomStack:

    def __init__(self, maxSize: int):
        self.stack=[]
        self.maxSize = maxSize
    def push(self, x: int) -> None:
        if len(self.stack)<self.maxSize:
            self.stack.append(x)
    def pop(self) -> int:
        if self.stack:
            temp = self.stack[-1]
            self.stack=self.stack[:-1]
            return temp
        else:
            return -1

    def increment(self, k: int, val: int) -> None:
        if len(self.stack)<k:
            for i in range(len(self.stack)):
                self.stack[i]+=val
        else:
            for i in range(k):
                self.stack[i]+=val

# Your CustomStack object will be instantiated and called as such:
# obj = CustomStack(maxSize)
# obj.push(x)
# param_2 = obj.pop()
# obj.increment(k,val)


814. Binary Tree Pruning

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pruneTree(self, root: TreeNode) -> TreeNode:
        def containsOne(node):
            if not node:
                return False 
            case1 = containsOne(node.left)
            case2 = containsOne(node.right)
            if not case1: node.left=None
            if not case2: node.right=None
            
            return node.val==1 or case1 or case2
        
        return root if containsOne(root) else None
            
            
29. Divide Two Integers

class Solution:
    def divide(self, dividend: int, divisor: int) -> int:
        max_int = 2147483647
        min_int = -2147483648
  
        if dividend==min_int and divisor==-1:
            return max_int
  
        quotient=0
        negatives=2
        if dividend>0:
            negatives-=1
            dividend=-dividend
  
        if divisor>0:
            negatives-=1
            divisor=-divisor
    
        while dividend-divisor<=0:
            quotient-=1
            dividend-=divisor
  
        return -quotient if negatives!=1 else quotient
        
 8. String to Integer (atoi)

def stringToInteger(s):
  if len(s)==0:
    return 0 
  
  ls = list(s.strip())
  sign=-1 if ls[0]=='-' else 1
  if ls[0] in ['+','-']: del ls[0]
  i=0
  res=0
  while i<len(ls) and ls[i].isdigit():
    res = res*10 + ord(ls[i])-ord('0')
    i+=1  
  return max(-2**31, min(res*sign, 2**31))

print(stringToInteger("   -42"))

Time is O(n) and space is O(n)


402. Remove K Digits

class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
        stack=[]
        for i in num:
            while k>0 and len(stack)>0 and stack[-1]>i:
                stack.pop()
                k-=1
            stack.append(i)
        if k>0:
            stack = stack[:-k]
        return "".join(stack).lstrip("0") or "0"
  

523. Continuous Subarray Sum

class Solution:
    def checkSubarraySum(self, nums: List[int], k: int) -> bool:
        lookup={0:-1}
        total=0
        for i in range(len(nums)):
            if k!=0:
                total = (total + nums[i])%k
            else:
                total+= nums[i]
            
            if total not in lookup:
                lookup[total]=i
            else:
                if i-lookup[total]>=2:
                    return True
        return False 

179. Largest Number

from functools import cmp_to_key
class Solution:
    def largestNumber(self, nums: List[int]) -> str:
        def comp_function(x,y):
            if x+y>y+x:
                return 1
            elif x+y == y+x:
                return 0
            else:
                return -1
            
        
        nums=[str(i) for i in nums]
        nums.sort(key=cmp_to_key(comp_function), reverse=True)
        
        return ''.join(nums).lstrip('0') or '0'



402. Remove K Digits

class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
        stack=[]
        for i in num:
            while k>0 and len(stack)>0 and stack[-1]>i:
                k-=1
                stack.pop()
            
            stack.append(i)
        if k>0:
            stack=stack[:-k]
        
        return "".join(stack).lstrip('0') or "0"
        
        
130. Surrounded Regions
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        if not board:
            return 
        m,n=len(board),len(board[0])
        def dfs(i,j):
            directions=[(-1,0),(0,1),(1,0),(0,-1)]
            if 0<=i<len(board) and 0<=j<len(board[0]) and board[i][j]=='O':
                board[i][j]='N'
                for m,n in directions:
                    dfs(i+m,j+n)
        
        for i in range(m):
            if board[i][0]=="O": dfs(i,0)
            if board[i][n-1]=="O": dfs(i,n-1)
        
        for i in range(n):
            if board[0][i]=="O": dfs(0,i)
            if board[m-1][i]=="O": dfs(m-1,i)
        
        for i in range(m):
            for j in range(n):
                if board[i][j]!='N': board[i][j]='X'
                else:
                    board[i][j]='O'
                    
 5. Longest Palindromic Substring
class Solution:
    def longestPalindrome(self, s: str) -> str:
        res=''
        for i in range(len(s)):
            temp = self.helper(s,i,i)
            if len(temp)> len(res):
                res=temp
            
            temp = self.helper(s,i,i+1)
            if len(temp)>len(res):
                res=temp
        return res
    
    
    
    def helper(self,s,l,r):
        while l>=0 and r<len(s) and s[l]==s[r]:
            l-=1
            r+=1
        return s[l+1:r]
        

98. Validate Binary Search Tree
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        def helper(node, lower=float('-inf'), upper=float('inf')):
            if not node:
                return True
            val = node.val
            if val<=lower or val>=upper:
                return False
            if not helper(node.right, val,upper):
                return False
            if not helper(node.left,lower,val):
                return False
            return True
        
        return helper(root)
       
  
 1258. Synonymous Sentences
 
 class Solution:
    def generateSentences(self, synonyms: List[List[str]], text: str) -> List[str]:
        lookup = collections.defaultdict(dict)
        res = set()
        queue = collections.deque()
        queue.append(text)
        for i,j in synonyms:
            lookup[i][j]=1
            lookup[j][i]=1
        
        while queue:
            current = queue.popleft()
            res.add(current)
            words = current.split()
            for i,w in enumerate(words):
                if w in lookup.keys():
                    for newWord in lookup[w]:
                        newSent = " ".join(words[:i]+[newWord]+words[i+1:])
                        if newSent not in res:
                            queue.append(newSent)
        return sorted(list(res))
        
 151. Reverse Words in a String
 
class Solution:
    def reverseWords(self, s: str) -> str:
        s= [i for i in s]
        self.reverse(s,0,len(s)-1)
        previous =0 
        for i in range(len(s)):
            if s[i]==" ":
                self.reverse(s,previous,i-1)
                previous=i+1
            elif i == len(s)-1:
                self.reverse(s,previous,i)
        return "".join(s)
    def reverse(self, s,left, right):
        while left<right:
            s[left], s[right] = s[right],s[left]
            left+=1
            right-=1
            
841. Keys and Rooms

class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        seen =[False]* len(rooms)
        seen[0] = True
        stack=[0]
        while stack:
            cur= stack.pop()
            for room in rooms[cur]:
                if not seen[room]:
                    seen[room]=True
                    stack.append(room)
        return all(seen)
        

901. Online Stock Span

class StockSpanner:

    def __init__(self):
        self.stack=[]
        self.index =-1

    def next(self, price: int) -> int:
        self.index+=1
        while self.stack and self.stack[-1][1]<=price:
            self.stack.pop()
            
        if not self.stack:
            self.stack.append((self.index,price))
            return self.index+1
        temp = self.stack[-1][0]
        self.stack.append((self.index,price))
        return self.index - temp
# Your StockSpanner object will be instantiated and called as such:
# obj = StockSpanner()
# param_1 = obj.next(price)
        
515. Find Largest Value in Each Tree Row

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def largestValues(self, root: TreeNode) -> List[int]:
        if not root:
            return 
        queue= collections.deque([root])
        res=[]
        while queue:
            n = len(queue)
            temp=[]
            for _ in range(n):
                node = queue.popleft()
                temp.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
                
            res.append(max(temp))
        
        return res 

1011. Capacity To Ship Packages Within D Days

class Solution:
    def shipWithinDays(self, weights: List[int], D: int) -> int:
        low, high = max(weights), sum(weights)
        while low<high:
            mid = (low+high)//2
            cur_capacity = 0
            cur_ships =1
            
            for w in weights:
                cur_capacity+=w
                if cur_capacity>mid:
                    cur_capacity=w
                    cur_ships+=1
                
            if cur_ships>D:
                low=mid+1
            
            else:
                high = mid
            
        return low
        
Time is O(nlogn) and space is O(1)

529. Minesweeper
class Solution:
    def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:
        row,col = click[0],click[1]
        directions=[(-1,0),(0,-1),(1,0),(0,1),(-1,-1),(1,1),(1,-1),(-1,1)]
        if board[row][col]=="M":
            board[row][col]="X"
            return board
        
        else:
            count=0
            for m, n in directions:
                new_row = row+m
                new_col = col +n
                if not (0<=new_row<len(board) and 0<=new_col<len(board[0])):
                    continue
                if board[new_row][new_col]=="M":
                    count+=1
            if count:
                board[row][col]=str(count)
            
            else:
                board[row][col]="B"
                for m, n in directions:
                    new_row = row+m
                    new_col = col +n
                    if not (0<=new_row<len(board) and 0<=new_col<len(board[0])):
                        continue
                    if board[new_row][new_col]=="E":
                        self.updateBoard(board,(new_row,new_col))
        return board
   Time is O(mn) space is O(1)
   
   
1135. Connecting Cities With Minimum Cost

import heapq
class Solution:
    def minimumCost(self, N: int, connections: List[List[int]]) -> int:
        lookup = collections.defaultdict(list)
        for i,j,k in connections:
            lookup[i].append((k,j))
            lookup[j].append((k,i))
        visited_set =set()
        total_cost=0
        queue = [(0,N)]
        while queue and len(visited_set)<N:
            cur_cost,cur_city = heapq.heappop(queue)
            if cur_city not in visited_set:
                visited_set.add(cur_city)
                total_cost+=cur_cost
                for next_city_cost, next_city in lookup[cur_city]:
                    heapq.heappush(queue,(next_city_cost, next_city))
        
        return total_cost if len(visited_set)==N else -1
  
  Time is O(ElogE) and space is O(E)
  
1004. Max Consecutive Ones III
O(n) and O(1class Solution:

    def longestOnes(self, A: List[int], K: int) -> int:
        left,right = 0,0 
        for right in range(len(A)):
            K-=1-A[right]
            if K<0:
                K+= 1-A[left]
                left+=1
        return right -left +1
        
238. Product of Array Except Self

class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        ans=[0]*len(nums)
        ans[0]=1
        for i in range(1,len(nums)):
            ans[i]= ans[i-1]*nums[i-1]  
        right=1
        for j in reversed(range(len(nums))):
            ans[j]=ans[j]*right
            right*=nums[j]
        return ans

1031. Maximum Sum of Two Non-Overlapping Subarrays

Time is O(n) space is O(n)
class Solution:
    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:
        for i in range(1,len(A)):
            A[i]+=A[i-1]
        res,lmax,rmax = A[L+M-1],A[L-1],A[M-1]
        for i in range(L+M,len(A)):
            lmax = max(lmax, A[i-M]-A[i-L-M])
            res = max(res,lmax+A[i]-A[i-M])
        
        for i in range(L+M,len(A)):
            rmax = max(rmax, A[i-L]-A[i-L-M])
            res = max(res,rmax+A[i]-A[i-L])
        return res

49. Group Anagrams

import collections
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        lookup = collections.defaultdict(list)
        for i in strs:
            temp = "".join(sorted(i))
            if temp in lookup:
                lookup[temp].append(i)
            else:
                lookup[temp]=[i]
        
        res=[]
        for key in lookup.keys():
            res.append(lookup[key])
        
        return res

540. Single Element in a Sorted Array

O(log n) space is O(1)
class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        l,r= 0,len(nums)-1
        while l+1<r:
            mid = l +(r-l)//2
            if mid%2!=0:
                mid = mid -1
            
            if nums[mid]==nums[mid+1]:
                l= mid+2
            else:
                r=mid
        return nums[l]

173. Binary Search Tree Iterator

Time and space are both O(n)

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class BSTIterator:

    def __init__(self, root: TreeNode):
        self.stack=[]
        self.index =-1
        self.inorder(root)
    
    def inorder(self,root):
        if not root:
            return
        self.inorder(root.left)
        self.stack.append(root.val)
        self.inorder(root.right)
    def next(self) -> int:
        """
        @return the next smallest number
        """
        self.index +=1
        return self.stack[self.index]

    def hasNext(self) -> bool:
        """
        @return whether we have a next smallest number
        """
        return self.index+1<len(self.stack)


# Your BSTIterator object will be instantiated and called as such:
# obj = BSTIterator(root)
# param_1 = obj.next()
# param_2 = obj.hasNext()

1219. Path with Maximum Gold
Time: O(k * 4 ^ k + m * n), space: O(m * n),
class Solution:
    def getMaximumGold(self, grid: List[List[int]]) -> int:
        def dfs(grid,i,j,total,seen):
            directions=[(-1,0),(0,-1),(1,0),(0,1)]
            if not (0<=i<len(grid) and 0<=j<len(grid[0])) or grid[i][j]==0 or (i,j) in seen:  
                return total
            seen.add((i,j))
            total+=grid[i][j]
            mx=0
            for m,n in directions:
                new_row = i+m
                new_col = j+n
                mx = max(dfs(grid,new_row,new_col,total,seen),mx)
            seen.discard((i,j))
            return mx
        
        m,n = len(grid),len(grid[0])
        return max(dfs(grid,i,j,0,set()) for j in range(n) for i in range(m))
        
 1057. Campus Bikes
 Time is O(nlogn) and space is O(n)
 class Solution:
    def assignBikes(self, workers: List[List[int]], bikes: List[List[int]]) -> List[int]:
        distances=[]
        for i,worker in enumerate(workers):
            for j,bike in enumerate(bikes):
                distance = abs(worker[0]-bike[0])+abs(worker[1]-bike[1])
                distances.append((distance,i,j))
        
        results =[-1]*len(workers)
        distances.sort()
        allotted = set()
        for distance,i,j in distances:
            if results[i]==-1 and j not in allotted:
                results[i]=j
                allotted.add(j)
        return results
        
1209. Remove All Adjacent Duplicates in String II
Time is O(n) and space is O(n)
class Solution:
    def removeDuplicates(self, s: str, k: int) -> str:
        stack =[]
        for char in s:
            if not stack or stack[-1][0] !=char:
                stack.append((char,1))
            else:
                count = stack.pop()[1] +1
                if count<k:
                    stack.append((char,count))
            
        return "".join([e*c for e,c in stack])
        
        
694. Number of Distinct Islands

class Solution:
    def numDistinctIslands(self, grid: List[List[int]]) -> int:
        def dfs(i,j,positions,rel_pos):
            directions=[(0,1),(1,0),(-1,0),(0,-1)]
            grid[i][j]=-1

            for m,n in directions:
                new_row = i+m
                new_col = j+n 
                if (0<=new_row<len(grid) and 0<=new_col<len(grid[0])) and grid[new_row][new_col]==1:
                    new_rel = (rel_pos[0]+m,rel_pos[1]+n)
                    postions.append(new_rel) 
                    dfs(new_row, new_col, postions,new_rel)
  
        num_shapes = set()
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j]==1:
                    postions=[]
                    dfs(i,j,postions,(0,0))
                    num_shapes.add(tuple(postions))
        return len(num_shapes)


1019. Next Greater Node In Linked List
Time and space O(n)
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def nextLargerNodes(self, head: ListNode) -> List[int]:
        pos=-1
        stack=[]
        ans=[]
        
        while head:
            pos+=1
            ans.append(0)
            while stack and stack[-1][1]<head.val:
                idx,_= stack.pop()
                ans[idx]=head.val
            stack.append((pos,head.val))
            head=head.next
        return ans 
        
        

328. Odd Even Linked List
O(n) and space is O(1) 

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def oddEvenList(self, head: ListNode) -> ListNode:
        if not head:return None
        odd= head 
        even= head.next 
        evenhead = even 
        
        while even and even.next:
            odd.next = even.next
            odd = odd.next
            even.next = odd.next
            even = even.next
        
        odd.next = evenhead
        
        return head
        
430. Flatten a Multilevel Doubly Linked List
Time and space is O(n)

"""
# Definition for a Node.
class Node:
    def __init__(self, val, prev, next, child):
        self.val = val
        self.prev = prev
        self.next = next
        self.child = child
"""

class Solution:
    def flatten(self, head: 'Node') -> 'Node':
        if not head:
            return None 
        stack=[head]
        prev = Node(0)
        
        while stack:
            root = stack.pop()
            root.prev = prev
            prev.next = root
            prev = root
            
            if root.next:
                stack.append(root.next)
            
            if root.child:
                stack.append(root.child)
                root.child = None
            
        head.prev = None
        return head 

289. Game of Life
Time is O(n*m) and space is O(1)

class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        def count(x,y):
            res=0
            for r in range(x-1,x+2):
                for c in range(y-1,y+2):
                    if (r!=x or c!=y) and 0<=r<len(board) and 0<=c<len(board[0]) and board[r][c]>0:
                        res+=1
            return res
        
        
        for i in range(len(board)):
            for j in range(len(board[0])):
                board[i][j]= count(i,j)+1 if board[i][j]==1 else -count(i,j)
        
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] in {3,4,-3}:
                    board[i][j]=1
                else:
                    board[i][j]=0
                    
538. Convert BST to Greater Tree
Time and space complexity is O(n)

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def __init__(self):
        self.total =0
    def convertBST(self, root: TreeNode) -> TreeNode:
        if root is not None:
            self.convertBST(root.right)
            self.total+=root.val
            root.val = self.total
            self.convertBST(root.left)
        
        return root
        

341. Flatten Nested List Iterator

# """
# This is the interface that allows for creating nested lists.
# You should not implement it, or speculate about its implementation
# """
#class NestedInteger:
#    def isInteger(self) -> bool:
#        """
#        @return True if this NestedInteger holds a single integer, rather than a nested list.
#        """
#
#    def getInteger(self) -> int:
#        """
#        @return the single integer that this NestedInteger holds, if it holds a single integer
#        Return None if this NestedInteger holds a nested list
#        """
#
#    def getList(self) -> [NestedInteger]:
#        """
#        @return the nested list that this NestedInteger holds, if it holds a nested list
#        Return None if this NestedInteger holds a single integer
#        """
import collections
class NestedIterator:
    def __init__(self, nestedList: [NestedInteger]):
        self.q= collections.deque()
        self.flatten(nestedList)
    
    def flatten(self,nestedList):
        for i in nestedList:
            if i.isInteger():
                self.q.append(i.getInteger())
            else:
                self.flatten(i.getList())
    
    def next(self) -> int:
        return self.q.popleft()
    def hasNext(self) -> bool:
         return len(self.q)>0

# Your NestedIterator object will be instantiated and called as such:
# i, v = NestedIterator(nestedList), []
# while i.hasNext(): v.append(i.next())


1041. Robot Bounded In Circle
Time O(n) and space O(1)
# start position (0,0)
# visited_set
# for i in instructions:
#  if i == G : new_pos = (start[0]+1,start[1]+1)
# add=> new position to visited set 
# update the start position as new_pos
#
class Solution:
    def isRobotBounded(self, instructions: str) -> bool:
        x,y,dx,dy = 0,0,0,1
        for i in instructions:
            if i=="R": dx,dy = dy,-dx
            if i=="L": dx,dy = -dy,dx
            if i=="G": x,y = x+dx,y+dy
            
        return (x,y)==(0,0) or (dx,dy)!=(0,1)

96. Unique Binary Search Trees
O(n^2) and O(1)

class Solution:
    def numTrees(self, n: int) -> int:
        ds=[0]*(n+1)
        ds[0],ds[1]=1,1
        for i in range(2,n+1):
            for j in range(1,i+1):
                ds[i]+=(ds[j-1]*ds[i-j])
        
        return ds[n]

2. Add Two Numbers

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode, c=0) -> ListNode:
        val = l1.val + l2.val + c
        if val>=10:
            val = val -10
            c=1
        else:
            c=0
        
        res = ListNode(val)
        
        if l1.next or l2.next:
            if l1.next is None:
                l1.next = ListNode(0)
            if l2.next is None:
                l2.next = ListNode(0)
            
            res.next = self.addTwoNumbers(l1.next,l2.next,c)
        
        elif c!=0:
            res.next= ListNode(1)
        
        return res


445. Add Two Numbers II
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        last = None
        while head:
            # keep the next node
            tmp = head.next
            # reverse the link
            head.next = last
            # update the last node and the current node
            last = head
            head = tmp
        
        return last
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        l1 = self.reverseList(l1)
        l2 = self.reverseList(l2)
        
        carry=0
        head = None 
        while l1 or l2:
            x1 = l1.val if l1 else 0 
            x2 = l2.val if l2 else 0 
            
            val = x1+x2 + carry
            if val>=10:
                val= val-10
                carry=1
            else:
                carry =0
            
            cur = ListNode(val)
            cur.next = head
            head = cur
            
            l1 = l1.next if l1 else None 
            l2 = l2.next if l2 else None
            
        if carry !=0:
            cur = ListNode(carry)
            cur.next = head
            head = cur
        return head 
            
           
12. Integer to Roman

class Solution:
    def intToRoman(self, num: int) -> str:
        lookup ={1000:'M',900:'CM',500:'D',400:'CD',100:'C',90:'XC',50:'L',40:'XL',10:'X',9:'IX',5:'V',4:'IV',1:'I'}
        res=''
        for key in lookup.keys():
            if num==0:
                break
            
            count,num = divmod(num,key)
            res+=(count*lookup[key])
        return res
        
 13. Roman to Integer

class Solution:
    def romanToInt(self, s: str) -> int:
        lookup = {"I":1,"V":5,"X":10,"L":50,"C":100,"D":500,"M":1000}
        res =0 
        for i in range(len(s)):
            if i>0 and lookup[s[i]]>lookup[s[i-1]]:
                res+= lookup[s[i]]-2*lookup[s[i-1]]
            else:
                res+=lookup[s[i]]
        return res
        
449. Serialize and Deserialize BST

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
from collections import deque
class Codec:

    def serialize(self, root: TreeNode) -> str:
        """Encodes a tree to a single string.
        """
        if not root:
            return ""
        queue= deque([root])
        res=""
        while queue:
            cur = queue.popleft()
            if cur:
                res = res + str(cur.val)+","
                queue.append(cur.left)
                queue.append(cur.right)
            else:
                res = res + "None " +","
        return res[:-1]

    def deserialize(self, data: str) -> TreeNode:
        """Decodes your encoded data to tree.
        """
        if not data:
            return None
        data = data.split(",")
        root = TreeNode(int(data[0]))
        queue=deque([root])
        i=1
        while queue:
            cur = queue.popleft()
            if data[i]!="None":
                cur.left= TreeNode(int(data[i]))
                queue.append(cur.left)
            i+=1
            if data[i]!="None":
                cur.right = TreeNode(int(data[i]))
                queue.append(cur.right)
            i+=1
        return root
        

# Your Codec object will be instantiated and called as such:
# codec = Codec()
# codec.deserialize(codec.serialize(root))

399. Evaluate Division
O(n^2/m) where n is distinct values and m are the queries.

class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:
        
        lookup = collections.defaultdict(dict)
        for ([x,y], val) in zip(equations,values):
            lookup[x][y]=val
            lookup[y][x]=1/val
        
        def find_product(start,end):
            if start not in lookup or end not in lookup:
                return -1.0
            if start ==end:
                return 1.0
            queue =deque([(start,1.0)])
            visited ={start}
            while queue:
                cur_start, cur_val = queue.popleft() # a
                for child,val in lookup[cur_start].items(): #child b and 2.0
                    if child in visited:
                        continue
                    new_val = cur_val * val      # new_val 2.0
                    if child ==end:              # b!=c
                        return new_val
                    lookup[start][child]=new_val  #a:{b:2},b:{a:0.5}
                    lookup[child][start]=1/new_val
                    visited.add(child)
                    queue.append((child,new_val))
            return -1.0
                    
        
        
        return [find_product(start,end) for [start,end] in queries]
        
        
926. Flip String to Monotone Increasing

class Solution:
    def minFlipsMonoIncr(self, S: str) -> int:
        n = len(S)
        count0 = S.count('0')
        count1=0
        res = n - count0 
        for i in range(n):
            if S[i]=='0':
                count0-=1
            else:
                res = min(res,count0+count1)
                count1+=1
        return res

875. Koko Eating Bananas
O(nlogm)
class Solution:
    def minEatingSpeed(self, piles: List[int], H: int) -> int:
        l,r =1,max(piles)
        
        while l < r:
            m = (l + r) // 2
            if sum(math.ceil(p/m) for p in piles) > H: l = m + 1
            else: r = m
        return l

165. Compare Version Numbers
O(m+n) and O(m+n)
class Solution:
    def compareVersion(self, version1: str, version2: str) -> int:
        v1 = version1.split('.')
        v2= version2.split('.')
        for i in range(max(len(v1),len(v2))):
            temp1 = int(v1[i]) if i<len(v1) else 0
            temp2 = int(v2[i]) if i<len(v2) else 0
            
            if temp1!=temp2:
                return -1 if temp1<temp2 else 1
        return 0 

61. Rotate List
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def rotateRight(self, head: ListNode, k: int) -> ListNode:
        if not head or not head.next:
            return head
        
        count= 1 
        last=head
        while last.next:
            count+=1
            last = last.next
        middle = head
        if k%count==0:
            return head
        
        for i in range(count-k%count-1):
            middle = middle.next
        
        new_head = middle.next
        last.next = head
        middle.next = None
        return new_head

1022. Sum of Root To Leaf Binary Numbers

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sumRootToLeaf(self, root: TreeNode, val=0) -> int:
        if not root:
            return 0
        val = 2*val + root.val
        if root.left == root.right:
            return val
        return self.sumRootToLeaf(root.left,val) + self.sumRootToLeaf(root.right,val)
        

1512. Number of Good Pairs
class Solution:
    def numIdenticalPairs(self, nums: List[int]) -> int:
        return sum(k * (k - 1) / 2 for k in collections.Counter(A).values())

339. Nested List Weight Sum

# """
# This is the interface that allows for creating nested lists.
# You should not implement it, or speculate about its implementation
# """
#class NestedInteger:
#    def __init__(self, value=None):
#        """
#        If value is not specified, initializes an empty list.
#        Otherwise initializes a single integer equal to value.
#        """
#
#    def isInteger(self):
#        """
#        @return True if this NestedInteger holds a single integer, rather than a nested list.
#        :rtype bool
#        """
#
#    def add(self, elem):
#        """
#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.
#        :rtype void
#        """
#
#    def setInteger(self, value):
#        """
#        Set this NestedInteger to hold a single integer equal to value.
#        :rtype void
#        """
#
#    def getInteger(self):
#        """
#        @return the single integer that this NestedInteger holds, if it holds a single integer
#        Return None if this NestedInteger holds a nested list
#        :rtype int
#        """
#
#    def getList(self):
#        """
#        @return the nested list that this NestedInteger holds, if it holds a nested list
#        Return None if this NestedInteger holds a single integer
#        :rtype List[NestedInteger]
#        """

class Solution:
    def depthSum(self, nestedList: List[NestedInteger]) -> int:
        if len(nestedList)==0:
            return 0 
        stack=[]
        for i in nestedList:
            stack.append((i,1))
        total=0
        while stack:
            node,d = stack.pop(0)
            if node.isInteger():
                total= total +d*node.getInteger()
            else:
                for i in node.getList():
                    stack.append((i,d+1))
        return total

922. Sort Array By Parity II

class Solution:
    def sortArrayByParityII(self, A: List[int]) -> List[int]:
        i=0
        j=1 
        while i<len(A) and j<len(A):
            if A[i]%2==0:
                i+=2
            elif A[j]%2==1:
                j+=2
            else:
                A[i],A[j]= A[j],A[i]
                i+=2
                j+=2
        return A
        
557. Reverse Words in a String III        
class Solution:
    def reverseWords(self, s: str) -> str:
        list_s = list(s)
        start=0
        end =0 
        while end<len(list_s):
            if end == len(list_s)-1:
                list_s= self.reverse(list_s,start,end)
            if list_s[end]==" ":
                list_s= self.reverse(list_s,start,end-1)
                start=end+1
            end+=1
        return "".join(list_s)
    
    def reverse(self,s_list,start,end):
        while start<end:
            s_list[start],s_list[end] = s_list[end],s_list[start]
            start+=1
            end-=1
        return s_list

359. Logger Rate Limiter

class Logger(object):

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self._d = {}

    def shouldPrintMessage(self, timestamp, message):
        """
        Returns true if the message should be printed in the given timestamp, otherwise returns false.
        If this method returns false, the message will not be printed.
        The timestamp is in seconds granularity.
        :type timestamp: int
        :type message: str
        :rtype: bool
        """

        if message in self._d and timestamp - self._d[message] < 10:
            return False
        else:
            self._d[message] = timestamp
            return True

977. Squares of a Sorted Array

class Solution:
    def sortedSquares(self, A: List[int]) -> List[int]:
        l,r= 0,len(A)-1
        res=collections.deque()
        while l<=r:
            left,right = abs(A[l]), abs(A[r])
            if left>right:
                res.appendleft(left*left)
                l+=1
            else:
                res.appendleft(right*right)
                r-=1
        return list(res)

897. Increasing Order Search Tree

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def increasingBST(self, root: TreeNode) -> TreeNode:
        def getInorder(root):
            return getInorder(root.left) + [root.val]+ getInorder(root.right) if root else []
        inorder_list = getInorder(root)
        res=cur = TreeNode(None)
        for v in inorder_list:
            cur.right = TreeNode(v)
            cur = cur.right
        return res.right
        
        
1299. Replace Elements with Greatest Element on Right Side

class Solution:
    def replaceElements(self, arr: List[int],mx=-1) -> List[int]:
        for i in range(len(arr)-1,-1,-1):
            arr[i],mx= mx, max(mx,arr[i])
        return arr
        
617. Merge Two Binary Trees

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:
        if t1 and t2:
            root = TreeNode(t1.val + t2.val)
            root.left = self.mergeTrees(t1.left, t2.left)
            root.right = self.mergeTrees(t1.right, t2.right)
            return root
        else:
            return t1 or t2

496. Next Greater Element I

class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        d = {}
        st = []
        ans = []
        
        for x in nums2:
            while len(st) and st[-1] < x:
                d[st.pop()] = x
            st.append(x)
            

        for x in nums1:
            ans.append(d.get(x, -1))
            
        return ans
        
118. Pascal's Triangle

class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        p = [[1] * (i+1) for i in range(numRows)]
        for i in range(numRows):
            for j in range(1,i):
                p[i][j] = p[i-1][j-1]+p[i-1][j] 
        return p 
        
953. Verifying an Alien Dictionary

class Solution:
    def isAlienSorted(self, words: List[str], order: str) -> bool:
        lookup = {char:ind for ind,char in enumerate(order)}
        words = [[lookup[ch] for ch in w ]for w in words]
        return all(w1<=w2 for w1,w2 in zip(words,words[1:]))

1071. Greatest Common Divisor of Strings

class Solution:
    def gcdOfStrings(self, str1: str, str2: str) -> str:
        if str1+str2 != str2+str1:
            return ''
        elif str1 == str2:
            return str1
        else:
            length = gcd(len(str1),len(str2))
            return self.gcdOfStrings(str1[:length], str2[:length])

257. Binary Tree Paths
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        if not root:
            return []
        queue = collections.deque([(root,'')])
        res=[]
        while queue:
            cur,path = queue.popleft()
            if not cur.left and not cur.right:
                res.append(path+str(cur.val))
            if cur.left:
                queue.append((cur.left,path+str(cur.val)+'->'))
            if cur.right:
                queue.append((cur.right,path+str(cur.val)+'->'))
        
        return res

453. Minimum Moves to Equal Array Elements

class Solution:
    def minMoves(self, nums: List[int]) -> int:
        nums.sort()
        c=0
        for i in range(len(nums)-1,-1,-1):
            if nums[i]==nums[0]:
                break
            c+= nums[i]-nums[0]
        return c 

Kth Largest Element in a Stream

import heapq
class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        self.k = k
        self.my_heap =[]
        for n in nums:
            self.add(n)
    def add(self, val: int) -> int:
        heapq.heappush(self.my_heap,val)
        while len(self.my_heap)>self.k:
            heapq.heappop(self.my_heap)
        return self.my_heap[0]

1013. Partition Array Into Three Parts With Equal Sum

class Solution:
    def canThreePartsEqualSum(self, A: List[int]) -> bool:
        total = sum(A)
        if total%3 !=0:
            return False
        count, cum, target = 0,0,total//3
        for n in A:
            cum+=n
            if cum == target:
                cum=0
                count+=1
        return count>=3

997. Find the Town Judge

class Solution:
    def findJudge(self, N: int, trust: List[List[int]]) -> int:
        trusted =[0]*(N+1)
        for a,b in trust:
            trusted[a]-=1
            trusted[b]+=1
        
        for i in range(1,N+1):
            if trusted[i]==N-1:
                return i
        return -1

415. Add Strings

class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        def convert(c): 
            return ord(c)-ord('0')
        x1=x2=0    
        for i in num1:
            x1=x1*10+ convert(i)
        for j in num2:
            x2=x2*10+convert(j)
        x=x1+x2
        return str(x)

543. Diameter of Binary Tree

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        self.diameter =1 
        def height(root):
            if not root:
                return 0 
            left = height(root.left)
            right = height(root.right)
            self.diameter = max(self.diameter, left+right+1)
            return max(left,right)+1
        
        height(root)
        return self.diameter -1

270. Closest Binary Search Tree Value

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def closestValue(self, root: TreeNode, target: float) -> int:
        if not root:
            return
        return closestHelper(root,target)
        
def closestHelper(root,target):
    closest=root.val
    node=root
    while node:
        if abs(target-node.val)<abs(target-closest):
            closest = node.val
        if node.val>target:
            node =node.left

        else:
            node = node.right
    return closest
                    


796. Rotate String

import collections 
class Solution:
    def rotateString(self, A: str, B: str) -> bool:
        stack1 = collections.deque()
        stack2 = collections.deque()
        l1 = len(A)
        l2 = len(B)
        
        if l1==0 and l2==0:
            return True
        if l1!=l2:
            return False
        
        for i in A:
            stack1.append(i)
        
        for j in B:
            stack2.append(j)
            
        for i in range(l1):
            if stack1==stack2:
                return True
            char = stack1.pop()
            stack1.insert(0,char)
        return False
        
   another solution i sreturn 
   
   return True if len(A) == len(B) and B in A+A else False 
   
   541. Reverse String II

class Solution:
    def reverseStr(self, s: str, k: int) -> str:
        a = list(s)
        for i in range(0,len(a),2*k):
            a[i:i+k] = reversed(a[i:i+k])
        return "".join(a)

235. Lowest Common Ancestor of a Binary Search Tree

class Solution:
    # @param {TreeNode} root
    # @param {TreeNode} p
    # @param {TreeNode} q
    # @return {TreeNode}
    def lowestCommonAncestor(self, root, p, q):
        if not root or not p or not q:
            return None
        if (max(p.val, q.val) < root.val):
            return self.lowestCommonAncestor(root.left, p, q)
        elif (min(p.val, q.val) > root.val):
            return self.lowestCommonAncestor(root.right, p, q)
        else:
            return root

1010. Pairs of Songs With Total Durations Divisible by 60
class Solution:
    def numPairsDivisibleBy60(self, time: List[int]) -> int:
        result=0 
        count= collections.Counter()
        
        for t in time:
            result+= count[-t%60]
            count[t%60]+=1
        return result

628. Maximum Product of Three Numbers
class Solution:
    def maximumProduct(self, nums: List[int]) -> int:
        nums.sort()
        return max(nums[0] *nums[1] *nums[-1], nums[-1]*nums[-2]*nums[-3])
