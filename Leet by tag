Linear Structure Basics
Includes: String, Array, Linked List

Difficulty Level: ( Easy | Medium )



Must-Do
LeetCode88. Merge Sorted Array:--
        i=m-1
        k= len(nums1)-1
        j=n-1
        while i>=0 and j>=0:
          if nums1[i]<nums2[j]:
            nums1[k] = nums2[j]
            j-=1
            k-=1
          else:
            nums1[k]=nums1[i]
            i-=1
            k-=1
       nums1[:j+1] = nums2[:j+1]

LeetCode186. Reverse Words in a String II
             
             1st i need to define a reverse function which takes list, left and right pointers :- 
             2) revesrse the entire list using the function
             3) for loop over the list and check for empty space element and run the below function:
             self.reverse(s,0,len(s)-1) ===> reverses the list
             previous =0 
             for i in range(len(s)):
               if s[i]==" ":
                self.reverse(s,previous,i-1)
                previous=i+1
               elif s[i] == len(s)-1:
                self.reverse(s,previous,i)
             def reverse(self, s,left, right):
              while left<right:
                 s[left], s[right] = s[right],s[left]
                 left+=1
                 right-=1
            
              

LeetCode1. Two Sum
import collections
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        my_dict = {k:v for v,k in enumerate(nums)}
        for i in range(len(nums)):
            temp_res = target - nums[i]
            if temp_res in my_dict and my_dict[temp_res]!=i:
                return [i,my_dict[temp_res]]

LeetCode143. Reorder List

class Solution:
    def reorderList(self, head: ListNode) -> None:
        """
        Do not return anything, modify head in-place instead.
        """
        if not head:
            return
        fast=slow=head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        
        previous,cur = None, slow 
        while cur:
            cur.next,previous,cur = previous,cur,cur.next
        
        first,second = head,previous
        while second.next:
            first.next,first = second,first.next
            second.next,second = first,second.next

LeetCode92. Reverse Linked List II
 dummy=ListNode(0)
        dummy.next = head
        
        previous,cur= dummy,head
        for _ in range(m-1):
            cur= cur.next
            previous=previous.next
        for _ in range(n-m):
            temp=cur.next
            cur.next=temp.next
            temp.next=previous.next
            previous.next= temp
        return dummy.next
LeetCode56. Merge Intervals
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        sorted(intervals)
        res=[]
        for i in intervals:
            if not res or res[-1][1]<i[0]:
                res.append(i)
            else:
                res[-1][1]=max(res[-1][1],i[1])
        return res

LeetCode20. Valid Parentheses
class Solution:
    def isValid(self, s: str) -> bool:
        stack=[]
        my_dict = {"]":"[","}":"{",")":"("}
        for i in s:
            if i in my_dict:
                top_el = stack.pop() if stack else "#"
                if top_el != my_dict[i]:
                    return False
            else:
                stack.append(i)
        return not stack

LeetCode75. Sort Colors
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        red,white,blue = 0,0,len(nums)-1
        while white<blue:
            if nums[white]==0:
                nums[red],nums[white]= nums[white],nums[red]
                red+=1
                white+=1
            elif nums[white]==1:
                white+=1
            else:
                nums[white],nums[blue]=nums[blue],nums[white]
                blue-=1
                white+=1
LeetCode155. Min Stack


LeetCode277. Find the Celebrity
class Solution:
    def findCelebrity(self, n: int):
        candidate=0
        for i in range(1,n):
            if knows(candidate,i):
                candidate=i
        for i in range(n):
            candidate_knows_i = knows(candidate,i)
            i_knows_cand= knows(i,candidate)
            if i!=candidate and (candidate_knows_i or not i_knows_cand):
                return -1
        return candidate

LeetCode281. Zigzag Iterator
class ZigzagIterator:
    def __init__(self, v1: List[int], v2: List[int]):
        self.queue = [_ for _ in (v1,v2) if _]

    def next(self) -> int:
        v=self.queue.pop(0)
        res=v.pop(0)
        if v:
            self.queue.append(v)
        return res
            
    def hasNext(self) -> bool:
        if self.queue:
            return True
        else:
            return False

57. insert interva
class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        if not intervals and newInterval:
            return [newInterval]
        i=0
        res=[]
        while i<len(intervals):
            if intervals[i][1]>= newInterval[0] and intervals[i][1]<= newInterval[1] :
                intervals[i][1] = max(intervals[i][1],newInterval[1])
                intervals[i][0] = min(intervals[i][0],newInterval[0])
                res.append([intervals[i][0],intervals[i][1]])
                newInterval=[float('inf'),float('inf')]
            else:
                res.append(intervals[i])
            i+=1
        if newInterval!=[float('inf'),float('inf')]:
            res.append(newInterval)
        res.sort()
        final_res=[res[0]]
        j=1
        while j<len(res):
            if final_res[-1][1]>=res[j][0]:
                final_res[-1][1]=max(final_res[-1][1],res[j][1])
            else:
                final_res.append(res[j])
            j+=1
        return final_res
71. Simplify Path

15. 3Sum
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        res = set()
        i =0
        nums.sort()
        while i<len(nums)-2:
            left,right=i+1,len(nums)-1
            while left<right:
                temp = nums[left]+nums[right]+nums[i]
                if temp>0:
                    right-=1
                elif temp<0:
                    left+=1
                else:
                    res.add((nums[left],nums[right],nums[i]))
                    left+=1
            i+=1
        return list(res)



Optional
LeetCode234. Palindrome Linked List

LeetCode283. Move Zeros

LeetCode242. Valid Anagram

16. 3sum closest

246. Strobogrammatic Number

82. Remove Duplicates from Sorted list II

380. Insert delete getrandom O(1)

11 container with most water

189 rotate array

48 rotate image

225 implement stack using queues








Linear Structure Advanced
Includes: String, Array, Linked List
Difficulty Level: ( Medium | Hard )


Must-Do
LeetCode259. 3Sum Smaller

LeetCode532. K-diff Pairs in an Array

LeetCode567. Permutation in String

LeetCode76. Minimum Window Substring

LeetCode85. Maximal Rectangle

LeetCode475. Heaters

LeetCode340. Longest Substring with At Most K Distinct Characters

LeetCode42. Trapping Rain Water

LeetCode239. Sliding Window Maximum

LeetCode274. H-Index

LeetCode275. H-Index II

LC 26. Remove Duplicates from Sorted Array

LC 80. Remove Duplicates from Sorted Array II

LC 442. Find All Duplicates in an Array

LC 448. Find All Numbers Disappeared in an Array

LC 41. First Missing Positive

LC 268. Missing Number

LC 287. Find the Duplicate Number

LC 54 Spiral Matrix

84. Largest Rectangle in Histogram (H)

105 Construct Binary Tree from Preorder and Inorder Traversal





Optional
LeetCode658. Find K Closest Elements

LeetCode159. Longest Substring with At Most Two Distinct Characters

LC 316. Remove Duplicate Letters

LC 142. Linked List Cyle II

LC 224 Basic Calculator

LC 227 Basic Calculator II

LC 59 Spiral Matrix II






Recursion + Search  - Basic
Includes: Recursion + Binary Search + Tree
Difficulty Level: ( Easy | Medium )



Must-Do
206. Reverse Linked List

LeetCode278. First Bad Version

LeetCode34. Search for a Range

LeetCode450. Delete Node in a BST

LeetCode156. Binary Tree Upside Down

LeetCode98. Validate Binary Search Tree

LeetCode236. Lowest Common Ancestor of a Binary Tree

LeetCode153. Find Minimum in Rotated Sorted Array

LeetCode154. Find Minimum in Rotated Sorted Array II

LeetCode144. Binary Tree Preorder Traversal

104. Maximum Depth of Binary Tree

111. Minimum Depth of Binary Tree

257. Binary Tree Paths

101. Symmetric Tree

110. Balanced Binary Tree





Optional
LeetCode235. Lowest Common Ancestor of a Binary Search Tree

LeetCode33. Search in Rotated Sorted Array

LeetCode94. Binary Tree Inorder Traversal

LeetCode145. Binary Tree Postorder Traversal

LeetCode102. Binary Tree Level Order Traversal

LeetCode81. Search in Rotated Sorted Array II

129. Sum Root to Leaf Numbers








Recursion + Search  - Advanced
Includes: Recursion + Binary Search + Tree
Difficulty Level: ( Medium | Hard )


Must-Do
LeetCode772. Basic Calculator III

LeetCode255. Verify Preorder Sequence in Binary Search Tree

LeetCode105. Construct Binary Tree from Preorder and Inorder Traversal

LeetCode436. Find Right Interval

LeetCode315. Count of Smaller Numbers After Self

LeetCode208. Implement trie tree

LeetCode29. Divide Two Integers

LeetCode307. Range Sum Query - Mutable

LeetCode4. Median of Two Sorted Arrays

LeetCode297. Serialize and Deserialize Binary Tree

LeetCode776. Split BST

LeetCode114. Flatten Binary Tree to Linked List

LeetCode298. Binary Tree Longest Consecutive Sequence

LeetCode99. Recover Binary Search Tree

QuickSort implementation

LeetCode384. Shuffle an Array

LeetCode378. Kth Smallest Element in a Sorted Matrix

LeetCode74 Search in 2D Matrix

LeetCode240 Search in 2D Matrix II





Optional
LeetCode303. Range Sum Query

LeetCode261. Graph Valid Tree

LeetCode230. Kth Smallest Element in a BST

LeetCode103. Binary Tree Zigzag Level Order Traversal

LeetCode367. Valid Perfect Square

LeetCode508. Most Frequent Subtree Sum

LeetCode250. Count Univalue Subtrees






Sorting | Graph  - Basic
Includes: Sorting | Graph | DFS | BFS
Difficulty Level: ( Easy | Medium )


Must-Do
75. Sort Colors

LeetCode133. Clone Graph

LeetCode207. Course Schedule

LeetCode210. Course Schedule II

LeetCode490. The Maze

LeetCode505. The Maze II

LeetCode46. Permutations

LeetCode47. Permutations II

LeetCode200. Number of Islands

LeetCode305. Number of Islands II

692. Top K Frequent Words

LeetCode286. Walls and Gates

LC 77 Combinations

LC 78 Subsets

52. N-Queens II





Optional
22. Generate Parentheses

LeetCode787. Cheapest Flights Within K Stops

499. The Maze III

222. Count Complete Tree Nodes

347. Top K Frequent Elements

295. Find Median from Data Stream

261. Graph Valid Tree

253. Meeting Room II

207. Course Schedule

339. Nested List Weight Sum

23. Merge k Sorted Lists

199. Binary Tree Right Side View

90. Subset II

301. Remove invalid parentheses(DFS & BFS)



Sorting | Graph  - Advanced
Includes: Sorting | Graph | DFS | BFS
Difficulty Level: ( Medium | Hard )


Must-Do
LeetCode74. Search in 2D Matrix

LeetCode240. Search in 2D Matrix II

LeetCode127. Word Ladder

LeetCode126. Word Ladder II

LeetCode286. Walls and Gates

LeetCode305. Number of Island II

LeetCode323. Number of Connected Components in an Undirected Graph

LeetCode353. SNAKE

LeetCode269. Alien Dictionary

LeetCode417. Pacific Atlantic Water Flow

LeetCode773. Sliding Puzzle

LeetCode547. Friend Circles

LeetCode425. Word Squares

LeetCode444. Sequence Reconstruction

LeetCode373. Find K Pairs with Smallest Sums

LeetCode45. Jump Game II




Optional
LeetCode785. Is Graph Bipartite

LeetCode839. Similar String Groups

LeetCode352. Data Stream as Disjoint Intervals

LeetCode973. Kth Closest Points

LeetCode684. Redundant Connection

LeetCode802. Find Eventual Safe States

LeetCode737. Sentence Similarity II

LeetCode317. Shortest Distance from All Buildings

LeetCode399. Evaluate Division







Memorization | DP  - Basic
Includes: Sorting | Graph | DFS | BFS
Difficulty Level: ( Easy | Medium )


Must-Do
LeetCode198. House Robber

LeetCode213. House Robber II

LeetCode322. Coin Change

LeetCode518. Coin Change II

39. Combination Sum

40. Combination Sum II

377. Combination Sum IV

72. Edit Distance

403. Frog Jump

309. Best Time to Buy and Sell Stock with Cooldown

LeetCode53. Maximum Subarray

LeetCode486. Predict the Winner =Pot of Gold Game

LeetCode139. Word Break

LeetCode300. Longest Increasing Subsequence

LeetCode152. Maximum Product Subarray





Optional
542 01 matrix

LeetCode.10 Regular Expression Matching

LeetCode.64 Minimum Path Sum

LeetCode.291 Word Pattern II

LeetCode.79 word search

216. Combination Sum III

70. Climbing Stairs

LeetCode279. Perfect Squares

LeetCode673. Number of Longest Increasing Subsequence

LeetCode140. Word Break II





Memorization | DP  - Advanced
Includes: Sorting | Graph | DFS | BFS
Difficulty Level: ( Medium | Hard )


Must-Do
LeetCode801. Minimum Swaps To Make Sequences Increasing

LeetCode790. Domino and Tromino Tiling

LeetCode764. Largest Plus Sign

LeetCode750. Number Of Corner Rectangles

LeetCode413. Arithmetic Slices

LeetCode446. Arithmetic Slices II - Subsequence

LeetCode132. Palindrome Partitioning II

LeetCode91. Decode Ways

LeetCode639. Decode Ways II

LeetCode354. Russian Doll Envelopes

LC 32. Longest Valid Parentheses

LC 55. Jump Game

LC 375. Guess Number Higher or Lower II

LC 363. Max Sum of Rectangle No Larger Than K

LC 44. Wildcard Matching



Optional
LC337. House Robber III

LC525. Contiguous Array

LC174. Dungeon Game

LC410. split array largest sum

LC5. Longest Palindromic Substring

LC516. Longest Palindromic Subsequence

LC312. burst ballons

LC212. Word Pattern II

LC 464. Can I Win

LeetCode787. Cheapest Flights Within K Stops

LC95. Unique Binary Search Trees II

LC96. Unique Binary Search Trees

LC97. Interleaving String

LC135. Candy

LC329. Longest Increasing Path in Matrix
